{% extends "layout.html" %}

{% block head %}
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/sentlevel.css') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/split.js/1.6.5/split.min.js"></script>
    <script src="{{ url_for('static', filename='scripts/alignments_v2.js') }}"></script>
    <style>
        /* Line numbers styling - using table layout */
        .amr-wrapper {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            overflow-x: auto;
        }

        .amr-table {
            display: table;
            width: 100%;
        }

        .amr-line-numbers {
            display: table-cell;
            width: 45px;
            padding: 0.5rem 8px;
            background-color: #f1f3f4;
            border-right: 1px solid #dee2e6;
            color: #6c757d;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
            text-align: right;
            user-select: none;
            vertical-align: top;
            white-space: pre;
        }

        .amr-content-cell {
            display: table-cell;
            vertical-align: top;
            width: 100%;
        }

        #amr {
            background: transparent;
            border: none;
            border-radius: 0;
        }

        #amr pre {
            margin: 0;
            padding: 0.5rem;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
    </style>
    <!-- Initialize state before loading any other scripts -->
    <script>
        window.state = {
            currentId: {{ snt_id }},
            docVersionId: {{ doc_version_id }},
            maxSentId: {{ info2display.sents|length }},
            language: "{{ lang }}",
            projectId: {{ project_id }}
        };
    </script>
    <!-- Load utilities first -->
    <script src="{{ url_for('static', filename='scripts/utils.js') }}"></script>
    <!-- Load application scripts -->
    <script src="{{ url_for('static', filename='scripts/sentLevel.js') }}"></script>
    <script src="{{ url_for('static', filename='scripts/penmanString2umrDict.js') }}"></script>
    <script src="{{ url_for('static', filename='scripts/umrDict2penmanString.js') }}"></script>
    <!-- Load temporary branch storage script first -->
    <script src="{{ url_for('static', filename='scripts/tempBranchStorage.js') }}"></script>
    <!-- Load relation editor script after branch storage script -->
    <script src="{{ url_for('static', filename='scripts/relation_editor.js') }}"></script>
    <!-- Clean branch operations implementation -->
    <script src="{{ url_for('static', filename='scripts/branch_operations.js') }}"></script>
    <!-- Load undo/redo manager for graph editing history -->
    <script src="{{ url_for('static', filename='scripts/undo_redo_manager.js') }}"></script>
    <!-- Load command line interface for branch operations -->
    <script src="{{ url_for('static', filename='scripts/umr_command_line.js') }}"></script>
    <!-- Inline parenthesis checker with modal -->
    <script>
        // Simple inline parenthesis checker
        let parenCheckerActive = false;

        function toggleParenChecker() {
            parenCheckerActive = !parenCheckerActive;
            const btn = document.getElementById('paren-check-btn');
            const amrPre = document.querySelector('#amr pre');

            if (parenCheckerActive) {
                btn.classList.remove('btn-outline-info');
                btn.classList.add('btn-warning');
                btn.innerHTML = '<i class="fas fa-times-circle"></i> Exit Checker';

                // Create a modal overlay with a copy of the graph
                createParenCheckerModal(amrPre.textContent);
            } else {
                btn.classList.remove('btn-warning');
                btn.classList.add('btn-outline-info');
                btn.innerHTML = '<i class="fas fa-check-circle"></i> Parens';

                // Remove the modal
                const modal = document.getElementById('paren-checker-modal');
                if (modal) {
                    modal.remove();
                }
            }
        }

        function createParenCheckerModal(graphText) {
            // Remove existing modal if any
            const existingModal = document.getElementById('paren-checker-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal overlay
            const modal = document.createElement('div');
            modal.id = 'paren-checker-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 10px;
                padding: 20px;
                max-width: 90%;
                max-height: 90%;
                overflow: auto;
                position: relative;
            `;

            // Create header
            const header = document.createElement('div');
            header.style.cssText = `
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #ccc;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <h4 style="margin: 0;">Parenthesis Checker - Click any ( or ) to highlight its match</h4>
                <button onclick="toggleParenChecker()" style="
                    background: #f44336;
                    color: white;
                    border: none;
                    padding: 5px 15px;
                    border-radius: 5px;
                    cursor: pointer;
                ">Close</button>
            `;

            // Create container for line numbers and content
            const codeContainer = document.createElement('div');
            codeContainer.style.cssText = `
                display: flex;
                background: #f5f5f5;
                border-radius: 5px;
                overflow: auto;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.5;
            `;

            // Create line numbers
            const lineNumbers = document.createElement('div');
            lineNumbers.style.cssText = `
                padding: 10px 5px;
                background: #e0e0e0;
                border-right: 1px solid #ccc;
                text-align: right;
                user-select: none;
                color: #666;
                min-width: 30px;
            `;

            // Count lines and create line numbers
            const lines = graphText.split('\n');
            for (let i = 1; i <= lines.length; i++) {
                lineNumbers.innerHTML += `${i}<br>`;
            }

            // Create the pre element with the graph
            const pre = document.createElement('pre');
            pre.style.cssText = `
                margin: 0;
                padding: 10px;
                cursor: pointer;
                white-space: pre;
                flex: 1;
                overflow-x: auto;
            `;

            // Process the text to make parentheses clickable
            pre.innerHTML = highlightParentheses(graphText);

            codeContainer.appendChild(lineNumbers);
            codeContainer.appendChild(pre);

            modalContent.appendChild(header);
            modalContent.appendChild(codeContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    toggleParenChecker();
                }
            });
        }

        function highlightParentheses(text) {
            let html = '';
            for (let i = 0; i < text.length; i++) {
                if (text[i] === '(' || text[i] === ')') {
                    html += `<span class="paren-char" data-pos="${i}" style="cursor: pointer;" onclick="highlightMatch(${i})">${escapeHtml(text[i])}</span>`;
                } else {
                    html += escapeHtml(text[i]);
                }
            }
            return html;
        }

        function highlightMatch(position) {
            const modal = document.getElementById('paren-checker-modal');
            if (!modal) return;

            const pre = modal.querySelector('pre');
            const text = pre.textContent;
            const matchPos = findMatchingParen(text, position);

            // Reset all highlights
            const spans = pre.querySelectorAll('.paren-char');
            spans.forEach(span => {
                span.style.background = 'transparent';
                span.style.color = 'inherit';
                span.style.fontWeight = 'normal';
            });

            // Highlight the clicked paren
            const clickedSpan = pre.querySelector(`[data-pos="${position}"]`);
            if (clickedSpan) {
                clickedSpan.style.background = 'yellow';
                clickedSpan.style.color = 'black';
                clickedSpan.style.fontWeight = 'bold';
            }

            // Highlight the matching paren
            if (matchPos !== -1) {
                const matchSpan = pre.querySelector(`[data-pos="${matchPos}"]`);
                if (matchSpan) {
                    matchSpan.style.background = 'lime';
                    matchSpan.style.color = 'black';
                    matchSpan.style.fontWeight = 'bold';

                    // Scroll to match if needed
                    matchSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            } else {
                // No match found - highlight in red
                if (clickedSpan) {
                    clickedSpan.style.background = 'red';
                    clickedSpan.style.color = 'white';
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        function findMatchingParen(text, position) {
            const char = text[position];
            if (char !== '(' && char !== ')') return -1;

            const isOpen = char === '(';

            if (isOpen) {
                let depth = 1;
                for (let i = position + 1; i < text.length; i++) {
                    if (text[i] === '(') depth++;
                    else if (text[i] === ')') {
                        depth--;
                        if (depth === 0) return i;
                    }
                }
            } else {
                let depth = 1;
                for (let i = position - 1; i >= 0; i--) {
                    if (text[i] === ')') depth++;
                    else if (text[i] === '(') {
                        depth--;
                        if (depth === 0) return i;
                    }
                }
            }
            return -1;
        }
    </script>

    <!-- Diff Viewer for comparing before/after changes -->
    <script>
        let diffViewerActive = false;
        let lastSavedState = null;

        // Initialize last saved state when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const amrElement = document.querySelector('#amr pre');
            if (amrElement) {
                lastSavedState = amrElement.textContent;
            }
        });

        function toggleDiffView() {
            diffViewerActive = !diffViewerActive;
            const btn = document.getElementById('diff-view-btn');

            if (diffViewerActive) {
                btn.classList.remove('btn-outline-success');
                btn.classList.add('btn-success');
                btn.innerHTML = '<i class="fas fa-times"></i> Hide Diff';

                // Get current state
                const amrElement = document.querySelector('#amr pre');
                const currentState = amrElement ? amrElement.textContent : '';

                // Get the comparison state (either from undo/redo manager or last saved)
                let previousState = lastSavedState || '';

                // Check if undo/redo manager has a previous state
                if (window.undoRedoManager && window.undoRedoManager.history.length > 0) {
                    // Get the first state in history (original state)
                    previousState = window.undoRedoManager.history[0];
                }

                // Create diff view modal
                createDiffViewModal(previousState, currentState);
            } else {
                btn.classList.remove('btn-success');
                btn.classList.add('btn-outline-success');
                btn.innerHTML = '<i class="fas fa-exchange-alt"></i> Diff';

                // Remove modal
                const modal = document.getElementById('diff-viewer-modal');
                if (modal) {
                    modal.remove();
                }
            }
        }

        function createDiffViewModal(beforeText, afterText) {
            // Remove existing modal if any
            const existingModal = document.getElementById('diff-viewer-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'diff-viewer-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create modal content
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 10px;
                padding: 20px;
                width: 90%;
                max-width: 1400px;
                height: 80%;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            `;

            // Create header
            const header = document.createElement('div');
            header.style.cssText = `
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #ccc;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <h4 style="margin: 0;">Graph Comparison View</h4>
                <div>
                    <button onclick="updateLastSavedState()" style="
                        background: #28a745;
                        color: white;
                        border: none;
                        padding: 5px 15px;
                        border-radius: 5px;
                        cursor: pointer;
                        margin-right: 10px;
                    ">Mark as Saved</button>
                    <button onclick="toggleDiffView()" style="
                        background: #f44336;
                        color: white;
                        border: none;
                        padding: 5px 15px;
                        border-radius: 5px;
                        cursor: pointer;
                    ">Close</button>
                </div>
            `;

            // Create comparison container
            const comparisonContainer = document.createElement('div');
            comparisonContainer.style.cssText = `
                display: flex;
                flex: 1;
                gap: 20px;
                overflow: hidden;
            `;

            // Create before panel
            const beforePanel = createDiffPanel('Before', beforeText, '#ffebee');

            // Create after panel
            const afterPanel = createDiffPanel('After (Current)', afterText, '#e8f5e9');

            // Highlight differences
            highlightDifferences(beforePanel.querySelector('pre'), afterPanel.querySelector('pre'), beforeText, afterText);

            comparisonContainer.appendChild(beforePanel);
            comparisonContainer.appendChild(afterPanel);

            modalContent.appendChild(header);
            modalContent.appendChild(comparisonContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close on click outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    toggleDiffView();
                }
            });
        }

        function createDiffPanel(title, text, bgColor) {
            const panel = document.createElement('div');
            panel.style.cssText = `
                flex: 1;
                display: flex;
                flex-direction: column;
                border: 1px solid #ddd;
                border-radius: 5px;
                overflow: hidden;
            `;

            const panelHeader = document.createElement('div');
            panelHeader.style.cssText = `
                padding: 10px;
                background: ${bgColor};
                font-weight: bold;
                border-bottom: 1px solid #ddd;
            `;
            panelHeader.textContent = title;

            const contentContainer = document.createElement('div');
            contentContainer.style.cssText = `
                flex: 1;
                overflow: auto;
                display: flex;
                background: #f5f5f5;
            `;

            // Add line numbers column
            const lineNumbers = document.createElement('div');
            lineNumbers.style.cssText = `
                padding: 10px 5px;
                background: #e0e0e0;
                border-right: 1px solid #ccc;
                text-align: right;
                user-select: none;
                color: #666;
                min-width: 50px;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.5;
                flex-shrink: 0;
                position: sticky;
                left: 0;
                z-index: 10;
            `;

            const lines = text.split('\n');
            for (let i = 1; i <= lines.length; i++) {
                lineNumbers.innerHTML += `${i}<br>`;
            }

            // Create pre element for content
            const pre = document.createElement('pre');
            pre.style.cssText = `
                margin: 0;
                padding: 10px;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.5;
                white-space: pre;
                overflow: visible;
                flex: 0 1 auto;
            `;
            pre.textContent = text;

            contentContainer.appendChild(lineNumbers);
            contentContainer.appendChild(pre);
            panel.appendChild(panelHeader);
            panel.appendChild(contentContainer);

            return panel;
        }

        function highlightDifferences(beforePre, afterPre, beforeText, afterText) {
            const beforeLines = beforeText.split('\n');
            const afterLines = afterText.split('\n');

            // Create a map of line content to track moves
            const beforeLineMap = new Map();
            const afterLineMap = new Map();

            // Build maps of lines and their positions
            beforeLines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!beforeLineMap.has(trimmed)) {
                    beforeLineMap.set(trimmed, []);
                }
                beforeLineMap.get(trimmed).push(idx);
            });

            afterLines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!afterLineMap.has(trimmed)) {
                    afterLineMap.set(trimmed, []);
                }
                afterLineMap.get(trimmed).push(idx);
            });

            // Use a simple LCS-based approach to detect actual changes
            // First pass: identify exact matches at same position
            const unchangedLines = new Set();
            const deletedLines = new Set();
            const addedLines = new Set();
            const movedLines = new Map();

            // Mark unchanged lines (same content, same position)
            const minLength = Math.min(beforeLines.length, afterLines.length);
            for (let i = 0; i < minLength; i++) {
                if (beforeLines[i] === afterLines[i]) {
                    unchangedLines.add(i);
                }
            }

            // Find truly deleted lines (not in after at all)
            beforeLines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (trimmed && !afterText.includes(trimmed)) {
                    deletedLines.add(idx);
                }
            });

            // Find truly added lines (not in before at all)
            afterLines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (trimmed && !beforeText.includes(trimmed)) {
                    addedLines.add(idx);
                }
            });

            // Detect moves: lines that exist in both but at different positions
            // and haven't been marked as unchanged
            beforeLines.forEach((line, beforeIdx) => {
                if (unchangedLines.has(beforeIdx) || deletedLines.has(beforeIdx)) {
                    return; // Skip unchanged or deleted lines
                }

                const trimmed = line.trim();
                if (trimmed) {
                    // Look for this line in a different position in after
                    afterLines.forEach((afterLine, afterIdx) => {
                        if (afterLine.trim() === trimmed && afterIdx !== beforeIdx && !unchangedLines.has(afterIdx)) {
                            // Only mark as moved if positions differ significantly
                            if (Math.abs(afterIdx - beforeIdx) > 0) {
                                movedLines.set(beforeIdx, afterIdx);
                                return;
                            }
                        }
                    });
                }
            });

            // Build HTML with highlighting
            let beforeHtml = '';
            let afterHtml = '';

            // Process before lines
            beforeLines.forEach((line, idx) => {
                if (deletedLines.has(idx)) {
                    // Line was deleted
                    beforeHtml += `<span style="background: #ffcdd2;" title="Deleted">${escapeHtml(line)}</span>\n`;
                } else if (movedLines.has(idx)) {
                    const newPos = movedLines.get(idx);
                    // Line was moved
                    beforeHtml += `<span style="background: #e3f2fd; border-left: 3px solid #2196F3;" title="Moved to line ${newPos + 1}">${escapeHtml(line)}</span>\n`;
                } else if (unchangedLines.has(idx)) {
                    // Line unchanged
                    beforeHtml += escapeHtml(line) + '\n';
                } else if (idx >= afterLines.length) {
                    // Line deleted (past end of after)
                    beforeHtml += `<span style="background: #ffcdd2;" title="Deleted">${escapeHtml(line)}</span>\n`;
                } else {
                    // Normal line or whitespace-only change
                    beforeHtml += escapeHtml(line) + '\n';
                }
            });

            // Process after lines
            afterLines.forEach((line, idx) => {
                if (addedLines.has(idx)) {
                    // Line was added
                    afterHtml += `<span style="background: #c8e6c9;" title="Added">${escapeHtml(line)}</span>\n`;
                } else if (unchangedLines.has(idx)) {
                    // Line unchanged
                    afterHtml += escapeHtml(line) + '\n';
                } else if (idx >= beforeLines.length) {
                    // Line added (past end of before)
                    afterHtml += `<span style="background: #c8e6c9;" title="Added">${escapeHtml(line)}</span>\n`;
                } else {
                    // Check if this line is the destination of a move
                    let isMovedTo = false;
                    let fromPos = -1;
                    for (const [from, to] of movedLines.entries()) {
                        if (to === idx) {
                            isMovedTo = true;
                            fromPos = from;
                            break;
                        }
                    }

                    if (isMovedTo) {
                        // Line was moved here
                        afterHtml += `<span style="background: #e3f2fd; border-left: 3px solid #2196F3;" title="Moved from line ${fromPos + 1}">${escapeHtml(line)}</span>\n`;
                    } else {
                        // Normal line
                        afterHtml += escapeHtml(line) + '\n';
                    }
                }
            });

            // Add legend
            const legend = `<div style="padding: 5px; background: #f5f5f5; border-bottom: 1px solid #ddd; font-size: 12px;">
                <span style="background: #c8e6c9; padding: 2px 5px; margin-right: 10px;">Added</span>
                <span style="background: #ffcdd2; padding: 2px 5px; margin-right: 10px;">Deleted</span>
                <span style="background: #e3f2fd; border-left: 3px solid #2196F3; padding: 2px 5px;">Moved</span>
            </div>`;

            beforePre.innerHTML = beforeHtml;
            afterPre.innerHTML = afterHtml;

            // Add legend to both panels
            const beforePanel = beforePre.parentElement.parentElement;
            const afterPanel = afterPre.parentElement.parentElement;

            // Insert legend after the panel header
            const beforeHeader = beforePanel.querySelector('div');
            const afterHeader = afterPanel.querySelector('div');

            if (beforeHeader && !beforePanel.querySelector('.diff-legend')) {
                const beforeLegend = document.createElement('div');
                beforeLegend.className = 'diff-legend';
                beforeLegend.innerHTML = legend;
                beforeHeader.after(beforeLegend);
            }

            if (afterHeader && !afterPanel.querySelector('.diff-legend')) {
                const afterLegend = document.createElement('div');
                afterLegend.className = 'diff-legend';
                afterLegend.innerHTML = legend;
                afterHeader.after(afterLegend);
            }
        }

        function updateLastSavedState() {
            const amrElement = document.querySelector('#amr pre');
            if (amrElement) {
                lastSavedState = amrElement.textContent;
                showNotification('Current state marked as saved', 'success');

                // Refresh the diff view
                if (diffViewerActive) {
                    const currentState = amrElement.textContent;
                    createDiffViewModal(lastSavedState, currentState);
                }
            }
        }
    </script>
    <!-- Load Underscore.js before lemmatizer -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.13.6/underscore-min.js"></script>
    <!-- Load lemmatizer library -->
    <script src="{{ url_for('static', filename='scripts/javascript-lemmatizer/js/lemmatizer.js') }}"></script>
    
    <!-- Copy annotation functionality -->
    <script>
        // Helper function to get CSRF token for API requests
        function getCsrfToken() {
            // Try to get the token from a meta tag
            const metaToken = document.querySelector('meta[name="csrf-token"]');
            if (metaToken) {
                return metaToken.getAttribute('content');
            }
            
            // Try to get it from a hidden input (common in Django/Flask)
            const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"], input[name="_csrf_token"], input[name="csrf_token"]');
            if (csrfInput) {
                return csrfInput.value;
            }
            
            // Return empty string if not found
            console.warn('CSRF token not found');
            return '';
        }
        
        // Function to update line numbers
        function updateLineNumbers() {
            const preElement = document.querySelector('#amr pre');
            const lineNumbersDiv = document.getElementById('line-numbers');

            if (!preElement || !lineNumbersDiv) return;

            // Get the text content
            const textContent = preElement.textContent || '';

            // Split by newlines
            const lines = textContent.split('\n');

            // Generate line numbers
            const lineNumbers = [];

            // Add an empty first line number to account for the empty first line in the graph
            lineNumbers.push('');

            // Then add numbered lines starting from 1
            // Use <= to include the last line
            for (let i = 1; i <= lines.length; i++) {
                lineNumbers.push(i);
            }

            // Update the line numbers div
            lineNumbersDiv.textContent = lineNumbers.join('\n');
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize line numbers
            setTimeout(updateLineNumbers, 100);

            // Watch for changes
            const observer = new MutationObserver(function() {
                setTimeout(updateLineNumbers, 100);
            });

            const amrElement = document.querySelector('#amr');
            if (amrElement) {
                observer.observe(amrElement, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            }

            // Move the edit mode toggle to the header after it's created
            setTimeout(function() {
                const toggleContainer = document.querySelector('.edit-toggle-container');
                const placeholder = document.getElementById('edit-mode-toggle-placeholder');

                if (toggleContainer && placeholder) {
                    // Move the toggle to the placeholder
                    placeholder.appendChild(toggleContainer);

                    // Restyle the toggle to be more compact
                    toggleContainer.style.margin = '0';
                    toggleContainer.style.padding = '5px 10px';
                    toggleContainer.style.backgroundColor = 'transparent';
                    toggleContainer.style.border = 'none';
                    toggleContainer.style.fontSize = '0.875rem';

                    // Hide the description text for a cleaner look
                    const descriptionText = toggleContainer.querySelector('.mode-description-text');
                    if (descriptionText) {
                        descriptionText.style.display = 'none';
                    }

                    // Make the label smaller
                    const toggleLabel = toggleContainer.querySelector('b');
                    if (toggleLabel && toggleLabel.parentElement) {
                        toggleLabel.parentElement.style.fontSize = '0.875rem';
                        toggleLabel.parentElement.style.marginLeft = '5px';
                    }

                    // Adjust switch size
                    const switchElement = toggleContainer.querySelector('.switch');
                    if (switchElement) {
                        switchElement.style.transform = 'scale(0.8)';
                        switchElement.style.marginRight = '8px';
                    }
                }
            }, 500); // Wait for relation_editor.js to create the toggle

            // Save annotation and alignments functionality

            const saveButton = document.getElementById('save-annotation-btn');
            if (saveButton) {
                saveButton.addEventListener('click', function() {
                    // Get the current annotation text
                    const annotationText = document.querySelector('#amr pre').textContent;
                    const docVersionId = document.getElementById('doc_version_id').value;
                    const sentId = document.getElementById('snt_id').value;
                    
                    // Show a spinner in the button while saving
                    const originalText = saveButton.innerHTML;
                    saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
                    saveButton.disabled = true;
                    
                    // Call API to save the annotation
                    fetch(`/update_annotation/${docVersionId}/${sentId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCsrfToken() // Use the same token function from other features
                        },
                        body: JSON.stringify({
                            annotation: annotationText,
                            operation: 'manual_save'
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log('Save successful:', data);
                        
                        // Also save alignments if they exist
                        if (window.currentAlignments) {
                            // Create a structured object with alignment data
                            const alignmentsToSave = {};
                            
                            // Convert the alignment data to the format expected by the server
                            Object.keys(window.currentAlignments).forEach(variable => {
                                alignmentsToSave[variable] = window.currentAlignments[variable];
                            });
                            
                            // Call the alignment save endpoint
                            return fetch('/save_alignments', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCsrfToken()
                                },
                                body: JSON.stringify({
                                    doc_version_id: docVersionId,
                                    sent_id: sentId,
                                    alignments: alignmentsToSave
                                })
                            });
                        }
                        
                        // If no alignments, just return a resolved promise
                        return Promise.resolve({ ok: true });
                    })
                    .then(response => {
                        if (response.ok === false) {
                            throw new Error('Failed to save alignments');
                        }
                        
                        // Show success message
                        saveButton.innerHTML = '<i class="fas fa-check"></i> Saved!';
                        saveButton.classList.remove('btn-outline-primary');
                        saveButton.classList.add('btn-success');
                        
                        // Create a notification
                        const notification = document.createElement('div');
                        notification.className = 'alert alert-success';
                        notification.style.position = 'fixed';
                        notification.style.top = '20px';
                        notification.style.left = '50%';
                        notification.style.transform = 'translateX(-50%)';
                        notification.style.zIndex = '9999';
                        notification.style.padding = '10px 20px';
                        notification.style.borderRadius = '4px';
                        notification.textContent = 'Annotation and alignments saved successfully!';
                        
                        // Add to document and remove after a delay
                        document.body.appendChild(notification);
                        setTimeout(() => {
                            notification.remove();
                        }, 3000);
                        
                        // Reset button after a delay
                        setTimeout(() => {
                            saveButton.innerHTML = originalText;
                            saveButton.classList.remove('btn-success');
                            saveButton.classList.add('btn-outline-primary');
                            saveButton.disabled = false;
                        }, 2000);
                    })
                    .catch(error => {
                        console.error('Error saving:', error);
                        
                        // Show error in button
                        saveButton.innerHTML = '<i class="fas fa-times"></i> Error!';
                        saveButton.classList.remove('btn-outline-primary');
                        saveButton.classList.add('btn-danger');
                        
                        // Create an error notification
                        const notification = document.createElement('div');
                        notification.className = 'alert alert-danger';
                        notification.style.position = 'fixed';
                        notification.style.top = '20px';
                        notification.style.left = '50%';
                        notification.style.transform = 'translateX(-50%)';
                        notification.style.zIndex = '9999';
                        notification.style.padding = '10px 20px';
                        notification.style.borderRadius = '4px';
                        notification.textContent = 'Error saving: ' + error.message;
                        
                        // Add to document and remove after a delay
                        document.body.appendChild(notification);
                        setTimeout(() => {
                            notification.remove();
                        }, 5000);
                        
                        // Reset button after a delay
                        setTimeout(() => {
                            saveButton.innerHTML = originalText;
                            saveButton.classList.remove('btn-danger');
                            saveButton.classList.add('btn-outline-primary');
                            saveButton.disabled = false;
                        }, 2000);
                    });
                });
            }
            
            // Validation button functionality
            const validateButton = document.getElementById('validate-annotation-btn');
            if (validateButton) {
                validateButton.addEventListener('click', function() {
                    // Get the current annotation text
                    const annotationText = document.querySelector('#amr pre').textContent;

                    // Get tokens from the sentence
                    const tokens = [];
                    document.querySelectorAll('.token-box').forEach(tokenBox => {
                        tokens.push(tokenBox.textContent.trim());
                    });

                    // Show loading state
                    const originalText = validateButton.innerHTML;
                    validateButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Validating...';
                    validateButton.disabled = true;

                    // Call validation API
                    fetch('/api/validate/graph', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCsrfToken()
                        },
                        body: JSON.stringify({
                            graph: annotationText,
                            tokens: tokens
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        // Display validation results
                        const resultsDiv = document.getElementById('validation-results');
                        const errorsDiv = document.getElementById('validation-errors');
                        const warningsDiv = document.getElementById('validation-warnings');

                        // Clear previous results
                        errorsDiv.innerHTML = '';
                        warningsDiv.innerHTML = '';

                        // Display errors
                        if (data.errors && data.errors.length > 0) {
                            errorsDiv.innerHTML = '<h6 class="text-danger"><i class="fas fa-times-circle"></i> Errors:</h6>';
                            const errorList = document.createElement('ul');
                            errorList.className = 'mb-0 text-danger';
                            data.errors.forEach(error => {
                                const li = document.createElement('li');
                                li.textContent = error;
                                errorList.appendChild(li);
                            });
                            errorsDiv.appendChild(errorList);
                        }

                        // Display warnings
                        if (data.warnings && data.warnings.length > 0) {
                            warningsDiv.innerHTML = '<h6 class="text-warning"><i class="fas fa-exclamation-triangle"></i> Warnings:</h6>';
                            const warningList = document.createElement('ul');
                            warningList.className = 'mb-0 text-warning';
                            data.warnings.forEach(warning => {
                                const li = document.createElement('li');
                                li.textContent = warning;
                                warningList.appendChild(li);
                            });
                            warningsDiv.appendChild(warningList);
                        }

                        // Show success if valid
                        if (data.valid) {
                            if (!data.warnings || data.warnings.length === 0) {
                                errorsDiv.innerHTML = '<div class="alert alert-success mb-0"><i class="fas fa-check-circle"></i> Graph is valid!</div>';
                            } else {
                                errorsDiv.innerHTML = '<div class="alert alert-warning mb-0"><i class="fas fa-check-circle"></i> Graph is valid with warnings</div>';
                            }
                        }

                        // Show results section
                        resultsDiv.style.display = 'block';

                        // Update button state
                        if (data.valid) {
                            validateButton.innerHTML = '<i class="fas fa-check"></i> Valid!';
                            validateButton.classList.remove('btn-outline-warning');
                            validateButton.classList.add('btn-success');
                        } else {
                            validateButton.innerHTML = '<i class="fas fa-times"></i> Invalid';
                            validateButton.classList.remove('btn-outline-warning');
                            validateButton.classList.add('btn-danger');
                        }

                        // Reset button after a delay
                        setTimeout(() => {
                            validateButton.innerHTML = originalText;
                            validateButton.classList.remove('btn-success', 'btn-danger');
                            validateButton.classList.add('btn-outline-warning');
                            validateButton.disabled = false;
                        }, 3000);
                    })
                    .catch(error => {
                        console.error('Validation error:', error);

                        // Show error message
                        const resultsDiv = document.getElementById('validation-results');
                        const errorsDiv = document.getElementById('validation-errors');
                        errorsDiv.innerHTML = `<div class="alert alert-danger mb-0"><i class="fas fa-times-circle"></i> Validation error: ${error.message}</div>`;
                        resultsDiv.style.display = 'block';

                        // Reset button
                        validateButton.innerHTML = '<i class="fas fa-times"></i> Error';
                        validateButton.classList.remove('btn-outline-warning');
                        validateButton.classList.add('btn-danger');

                        setTimeout(() => {
                            validateButton.innerHTML = originalText;
                            validateButton.classList.remove('btn-danger');
                            validateButton.classList.add('btn-outline-warning');
                            validateButton.disabled = false;
                        }, 3000);
                    });
                });
            }

            const copyButton = document.getElementById('copy-annotation-btn');
            if (copyButton) {
                copyButton.addEventListener('click', function() {
                    const annotationText = document.querySelector('#amr pre').textContent;
                    navigator.clipboard.writeText(annotationText)
                        .then(() => {
                            // Visual feedback for successful copy
                            const originalText = copyButton.innerHTML;
                            copyButton.innerHTML = '<i class="fas fa-check"></i> Copied!';
                            copyButton.classList.remove('btn-outline-secondary');
                            copyButton.classList.add('btn-success');
                            
                            setTimeout(() => {
                                copyButton.innerHTML = originalText;
                                copyButton.classList.remove('btn-success');
                                copyButton.classList.add('btn-outline-secondary');
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy text: ', err);
                            alert('Failed to copy text to clipboard');
                        });
                });
            }
            
            // Delete annotation functionality
            const deleteButton = document.getElementById('delete-annotation-btn');
            if (deleteButton) {
                deleteButton.addEventListener('click', function() {
                    // Show confirmation dialog
                    if (confirm('Are you sure you want to delete the entire annotation and all its alignments? This action cannot be undone.')) {
                        const docVersionId = document.getElementById('doc_version_id').value;
                        const sentId = document.getElementById('snt_id').value;
                        
                        // Call API to update the annotation with an empty string
                        fetch(`/update_annotation/${docVersionId}/${sentId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                annotation: '',
                                operation: 'delete_all',
                                clear_alignments: true
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                // Provide visual feedback
                                const originalText = deleteButton.innerHTML;
                                deleteButton.innerHTML = '<i class="fas fa-check"></i> Deleted!';
                                deleteButton.classList.remove('btn-outline-danger');
                                deleteButton.classList.add('btn-success');
                                
                                // Clear alignments in the UI immediately
                                if (window.currentAlignments) {
                                    window.currentAlignments = {};
                                    renderAlignments();
                                }
                                
                                // Show a notification about deleting annotation and alignments
                                const notification = document.createElement('div');
                                notification.className = 'alert alert-success';
                                notification.style.position = 'fixed';
                                notification.style.top = '20px';
                                notification.style.left = '50%';
                                notification.style.transform = 'translateX(-50%)';
                                notification.style.padding = '10px 20px';
                                notification.style.borderRadius = '5px';
                                notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                                notification.style.zIndex = '9999';
                                notification.innerHTML = `
                                    <strong>Success!</strong> Annotation and all alignments have been deleted.
                                `;
                                document.body.appendChild(notification);
                                
                                setTimeout(() => {
                                    // Remove the notification first
                                    document.body.removeChild(notification);
                                    // Reload the page to reflect the changes
                                    window.location.reload();
                                }, 1000);
                            } else {
                                alert('Failed to delete annotation: ' + data.message);
                            }
                        })
                        .catch(err => {
                            console.error('Failed to delete annotation: ', err);
                            alert('Failed to delete annotation: ' + err.message);
                        });
                    }
                });
            }
        });
    </script>
    
    <!-- Add Top functionality -->
    <script>
        // Initialize global variables
        window.selectedFrameConcept = null;
        window.selectedTokens = []; // Track selected tokens
        
        document.addEventListener('DOMContentLoaded', function() {
            // Find the Add Top button
            const addTopButton = document.getElementById('add-top-btn');
            
            // If button exists, add click event listener
            if (addTopButton) {
                console.log('Add Top button found and event listener attached');
                addTopButton.addEventListener('click', function(event) {
                    event.preventDefault(); // Prevent any default action
                    console.log('Add Top button clicked');
                    showAddTopDialog();
                });
            } else {
                console.log('Add Top button not found in the DOM');
            }
            
            // Function to show dialog for adding the top node
            async function showAddTopDialog() {
                // Get sentence tokens for display
                const sentenceTokens = extractSentenceTokens();
                console.log('Sentence tokens for Add Top:', sentenceTokens);
                
                // Create dialog container
                const dialogContainer = document.createElement('div');
                dialogContainer.className = 'add-top-dialog-container';
                dialogContainer.style.position = 'fixed';
                dialogContainer.style.top = '0';
                dialogContainer.style.left = '0';
                dialogContainer.style.width = '100%';
                dialogContainer.style.height = '100%';
                dialogContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                dialogContainer.style.display = 'flex';
                dialogContainer.style.justifyContent = 'center';
                dialogContainer.style.alignItems = 'center';
                dialogContainer.style.zIndex = '2000';
                
                // Create dialog
                const dialog = document.createElement('div');
                dialog.className = 'add-top-dialog';
                dialog.style.width = '700px';
                dialog.style.maxWidth = '90vw';
                dialog.style.maxHeight = '90vh';
                dialog.style.overflow = 'auto';
                dialog.style.backgroundColor = 'white';
                dialog.style.borderRadius = '8px';
                dialog.style.padding = '20px';
                dialog.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
                
                // Dialog header and basic content
                dialog.innerHTML = `
                    <h3 style="margin-top: 0; margin-bottom: 20px;">Create Top Node</h3>
                    <form id="add-top-form">
                        <!-- Node type selection -->
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Concept Type:</label>
                            <select id="concept-type" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                <option value="">Select type...</option>
                                <option value="token">Sentence Token</option>
                                <option value="discourse">Discourse Concept</option>
                                <option value="abstract">Abstract Concept</option>
                                <option value="ne">Named Entity</option>
                                <option value="non-event">Reification Roleset</option>
                                <option value="custom">Custom Concept</option>
                            </select>
                        </div>
                        
                        <!-- Container for token selection -->
                        <div id="token-selection-container" style="display: none; margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select a token:</label>
                            <div class="alert alert-info mb-2" style="font-size: 0.9rem; padding: 8px;">
                                <p class="mb-1"><strong>Note:</strong> Selected tokens will be automatically aligned to the created concept.</p>
                                <p class="mb-0">Alignments will appear in the right panel after creation.</p>
                            </div>
                            <div style="position: relative; margin-bottom: 8px;">
                                <input type="text" id="token-search" 
                                    style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" 
                                    placeholder="Type to search tokens...">
                            </div>
                            <div class="alert alert-secondary mb-2" style="font-size: 0.9rem; padding: 8px;">
                                <p class="mb-1"><strong>Multi-selection:</strong> Use these keys to select multiple tokens:</p>
                                <ul class="mb-0" style="padding-left: 20px;">
                                    <li><strong>Ctrl/Cmd+Click</strong>: Select/deselect multiple individual tokens</li>
                                    <li><strong>Shift+Click</strong>: Select a range of tokens</li>
                                </ul>
                                <p class="mb-0 mt-1"><small>Multi-selected tokens will be joined with hyphens, e.g., "token1-token2"</small></p>
                            </div>
                            <div id="tokens-container" style="max-height: 250px; overflow-y: auto; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                                <div id="tokens-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;">
                                    ${sentenceTokens.map(token => `
                                        <div class="token-item" 
                                             data-token="${token.text}" 
                                             data-token-index="${token.index}"
                                             data-full-text="${token.fullText}"
                                             style="padding: 8px; background-color: #f0f8ff; border-radius: 4px; cursor: pointer; text-align: center;">
                                            ${token.text}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <!-- Frame lookup results (added) -->
                            <div id="frame-lookup-container" style="margin-top: 16px; display: none;">
                                <label style="display: block; margin-bottom: 8px; font-weight: bold;">
                                    Available frames for <span id="selected-token-text" style="font-style: italic;"></span>:
                                </label>
                                <div style="background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 12px; max-height: 250px; overflow-y: auto;">
                                    <div id="lemma-container" style="margin-bottom: 8px;">
                                        <label style="font-weight: bold; margin-bottom: 4px; display: block;">Lemma:</label>
                                        <div id="lemma-value" style="padding: 4px 8px; background-color: #e9ecef; border-radius: 4px; display: inline-block;"></div>
                                    </div>
                                    
                                    <div id="frames-container" style="margin-top: 8px;">
                                        <label style="font-weight: bold; margin-bottom: 4px; display: block;">Frames:</label>
                                        <div id="frames-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 8px;">
                                            <!-- Frames will be populated here -->
                                        </div>
                                    </div>
                                    
                                    <div class="mt-3">
                                        <button type="button" id="use-token-as-is" class="btn btn-sm btn-secondary">
                                            Use token as is
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Container for discourse concept selection -->
                        <div id="discourse-selection-container" style="display: none; margin-bottom: 16px;">
                            <label for="discourse-concept" style="display: block; margin-bottom: 8px; font-weight: bold;">Select discourse concept:</label>
                            <div style="position: relative; margin-bottom: 8px;">
                                <input type="text" id="discourse-concept-search" 
                                    style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" 
                                    placeholder="Type to search discourse concepts...">
                            </div>
                            <select id="discourse-concept" size="10" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-height: 250px;">
                                <option value="">Select concept...</option>
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        
                        <!-- Container for abstract concept selection -->
                        <div id="abstract-selection-container" style="display: none; margin-bottom: 16px;">
                            <label for="abstract-concept" style="display: block; margin-bottom: 8px; font-weight: bold;">Select abstract concept:</label>
                            <div style="position: relative; margin-bottom: 8px;">
                                <input type="text" id="abstract-concept-search" 
                                    style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" 
                                    placeholder="Type to search abstract concepts...">
                            </div>
                            <select id="abstract-concept" size="10" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-height: 250px;">
                                <option value="">Select concept...</option>
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        
                        <!-- Container for named entity selection -->
                        <div id="ne-selection-container" style="display: none; margin-bottom: 16px;">
                            <label for="ne-type" style="display: block; margin-bottom: 8px; font-weight: bold;">Select named entity type:</label>
                            <div style="position: relative; margin-bottom: 8px;">
                                <input type="text" id="ne-type-search" 
                                    style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" 
                                    placeholder="Type to search entity types...">
                            </div>
                            <select id="ne-type" size="10" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-height: 250px;">
                                <option value="">Select entity type...</option>
                                <!-- Will be populated dynamically -->
                            </select>
                            
                            <!-- Name tokens selection (added for NE types) -->
                            <div id="name-tokens-container" style="display: none; margin-top: 16px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select name tokens:</label>
                                <div style="background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 12px; max-height: 250px; overflow-y: auto;">
                                    <div id="name-tokens-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;">
                                        <!-- Will be populated with tokens dynamically -->
                                    </div>
                                    <div id="selected-name-tokens" class="alert alert-info mt-3" style="display: none;">
                                        <p class="mb-1"><strong>Selected name tokens:</strong></p>
                                        <p id="selected-name-tokens-list" class="mb-0"></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Container for non-event roleset selection -->
                        <div id="non-event-selection-container" style="display: none; margin-bottom: 16px;">
                            <label for="non-event-roleset" style="display: block; margin-bottom: 8px; font-weight: bold;">Select reification roleset:</label>
                            <div style="position: relative; margin-bottom: 8px;">
                                <input type="text" id="non-event-roleset-search" 
                                    style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" 
                                    placeholder="Type to search rolesets...">
                            </div>
                            <select id="non-event-roleset" size="10" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-height: 250px;">
                                <option value="">Select roleset...</option>
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                        
                        <!-- Container for custom concept input -->
                        <div id="custom-concept-container" style="display: none; margin-bottom: 16px;">
                            <label for="custom-concept" style="display: block; margin-bottom: 8px; font-weight: bold;">Enter custom concept:</label>
                            <input type="text" id="custom-concept" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" placeholder="Enter concept...">
                        </div>
                        
                        <!-- Variable input -->
                        <div style="margin-bottom: 16px;">
                            <label for="variable-input" style="display: block; margin-bottom: 8px; font-weight: bold;">Variable (optional):</label>
                            <div class="input-group" style="display: flex;">
                                <input type="text" id="variable-input" style="flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px 0 0 4px;" placeholder="Auto-generated if left empty">
                                <button type="button" id="generate-variable-btn" style="padding: 8px 16px; background-color: #f5f5f5; border: 1px solid #ccc; border-left: none; border-radius: 0 4px 4px 0; cursor: pointer;">Auto-generate</button>
                            </div>
                        </div>
                        
                        <div style="text-align: right; margin-top: 20px;">
                            <button type="button" id="cancel-add-top" style="padding: 8px 16px; margin-right: 10px; border: 1px solid #ccc; background-color: #f5f5f5; border-radius: 4px; cursor: pointer;">Cancel</button>
                            <button type="submit" id="confirm-add-top" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Create Node</button>
                        </div>
                    </form>
                `;
                
                dialogContainer.appendChild(dialog);
                document.body.appendChild(dialogContainer);
                
                // Fetch required data from the server
                try {
                    // Get concept data from the server
                    const conceptsResponse = await fetch('/get_concepts');
                    const conceptsData = await conceptsResponse.json();
                    
                    console.log('Concepts data:', conceptsData);
                    
                    // Extract needed concept categories
                    const discourseConceptsList = conceptsData.discourse_concepts || [];
                    const neTypesList = conceptsData.ne_types || [];
                    const nonEventRolesetsList = conceptsData.non_event_rolesets || [];
                    
                    // Define abstract concepts list (simplified subset)
                    const abstractConceptsList = [
                        'person', 'individual-person', 'place', 'event', 'name', 'umr-choice',
                        'manner', 'umr-unknown', 'umr-unintelligible', 'umr-empty',
                        'date-entity', 'string-entity', 'ordinal-entity', 'url-entity',
                        'monetary-quantity', 'distance-quantity', 'temporal-quantity',
                        'date-interval', 'value-interval', 'between', 'relative-position'
                    ];
                    
                    // Populate the dropdowns with data
                    populateDropdown('discourse-concept', discourseConceptsList);
                    populateDropdown('abstract-concept', abstractConceptsList);
                    populateDropdown('ne-type', neTypesList);
                    populateDropdown('non-event-roleset', nonEventRolesetsList);
                    
                    // Setup filtering for dropdowns
                    setupFiltering('discourse-concept-search', 'discourse-concept', discourseConceptsList);
                    setupFiltering('abstract-concept-search', 'abstract-concept', abstractConceptsList);
                    setupFiltering('ne-type-search', 'ne-type', neTypesList);
                    setupFiltering('non-event-roleset-search', 'non-event-roleset', nonEventRolesetsList);
                    setupTokensFiltering('token-search', 'tokens-grid');
                    
                    // Show/hide appropriate containers based on concept type selection
                    const conceptTypeSelect = document.getElementById('concept-type');
                    conceptTypeSelect.addEventListener('change', function() {
                        // Reset name tokens if changing from NE type
                        if (this.value !== 'ne') {
                            resetNameTokens();
                        }
                        
                        // Hide all containers first
                        document.getElementById('token-selection-container').style.display = 'none';
                        document.getElementById('discourse-selection-container').style.display = 'none';
                        document.getElementById('abstract-selection-container').style.display = 'none';
                        document.getElementById('ne-selection-container').style.display = 'none';
                        document.getElementById('non-event-selection-container').style.display = 'none';
                        document.getElementById('custom-concept-container').style.display = 'none';
                        
                        // Show the selected container
                        const selectedType = this.value;
                        if (selectedType === 'token') {
                            document.getElementById('token-selection-container').style.display = 'block';
                        } else if (selectedType === 'discourse') {
                            document.getElementById('discourse-selection-container').style.display = 'block';
                        } else if (selectedType === 'abstract') {
                            document.getElementById('abstract-selection-container').style.display = 'block';
                        } else if (selectedType === 'ne') {
                            document.getElementById('ne-selection-container').style.display = 'block';
                        } else if (selectedType === 'non-event') {
                            document.getElementById('non-event-selection-container').style.display = 'block';
                        } else if (selectedType === 'custom') {
                            document.getElementById('custom-concept-container').style.display = 'block';
                        }
                    });
                    
                    // Function to reset name tokens selection
                    function resetNameTokens() {
                        // Clear the selected name tokens array
                        window.selectedNameTokens = [];
                        
                        // Hide the name tokens container
                        const nameTokensContainer = document.getElementById('name-tokens-container');
                        if (nameTokensContainer) {
                            nameTokensContainer.style.display = 'none';
                        }
                        
                        // Reset the display
                        updateSelectedNameTokensDisplay();
                    }
                    
                    // Set up named entity selection to show name tokens
                    const neTypeSelect = document.getElementById('ne-type');
                    const nameTokensContainer = document.getElementById('name-tokens-container');
                    
                    // Track selected name tokens
                    window.selectedNameTokens = [];
                    
                    // Add event listener for NE type selection
                    neTypeSelect.addEventListener('change', function() {
                        if (this.value) {
                            // Show the name tokens selection when an NE type is selected
                            nameTokensContainer.style.display = 'block';
                            populateNameTokensSelection();
                        } else {
                            nameTokensContainer.style.display = 'none';
                        }
                    });
                    
                    // Function to populate name tokens selection from sentence tokens
                    function populateNameTokensSelection() {
                        const nameTokensGrid = document.getElementById('name-tokens-grid');
                        nameTokensGrid.innerHTML = ''; // Clear existing content
                        
                        // Use the same sentence tokens as the token selection
                        const sentenceTokens = extractSentenceTokens();
                        
                        sentenceTokens.forEach(token => {
                            const tokenDiv = document.createElement('div');
                            tokenDiv.className = 'name-token-item';
                            tokenDiv.setAttribute('data-token', token.text);
                            tokenDiv.setAttribute('data-token-index', token.index);
                            tokenDiv.style.padding = '8px';
                            tokenDiv.style.backgroundColor = '#f0f8ff';
                            tokenDiv.style.borderRadius = '4px';
                            tokenDiv.style.cursor = 'pointer';
                            tokenDiv.style.textAlign = 'center';
                            tokenDiv.textContent = token.text;
                            
                            // Add click event to toggle selection
                            tokenDiv.addEventListener('click', function() {
                                const tokenText = this.getAttribute('data-token');
                                const tokenIndex = this.getAttribute('data-token-index');
                                
                                // Check if already selected
                                const isSelected = this.hasAttribute('data-selected');
                                
                                if (isSelected) {
                                    // Deselect
                                    this.removeAttribute('data-selected');
                                    this.style.backgroundColor = '#f0f8ff';
                                    
                                    // Remove from selectedNameTokens
                                    const index = window.selectedNameTokens.findIndex(t => 
                                        t.text === tokenText && t.index === tokenIndex);
                                    if (index !== -1) {
                                        window.selectedNameTokens.splice(index, 1);
                                    }
                                } else {
                                    // Select
                                    this.setAttribute('data-selected', 'true');
                                    this.style.backgroundColor = '#b3d9ff';
                                    
                                    // Add to selectedNameTokens
                                    window.selectedNameTokens.push({
                                        text: tokenText,
                                        index: tokenIndex
                                    });
                                }
                                
                                // Sort selected tokens based on their position in the sentence
                                window.selectedNameTokens.sort((a, b) => parseInt(a.index) - parseInt(b.index));
                                
                                // Update selected tokens display
                                updateSelectedNameTokensDisplay();
                            });
                            
                            nameTokensGrid.appendChild(tokenDiv);
                        });
                    }
                    
                    // Function to update the display of selected name tokens
                    function updateSelectedNameTokensDisplay() {
                        const selectedNameTokensContainer = document.getElementById('selected-name-tokens');
                        const selectedNameTokensList = document.getElementById('selected-name-tokens-list');
                        
                        if (window.selectedNameTokens.length > 0) {
                            selectedNameTokensContainer.style.display = 'block';
                            selectedNameTokensList.textContent = window.selectedNameTokens.map(t => t.text).join(' ');
                        } else {
                            selectedNameTokensContainer.style.display = 'none';
                        }
                    }
                    
                    // Set up click events for token items
                    document.querySelectorAll('.token-item').forEach(item => {
                        item.addEventListener('click', function(event) {
                            const tokenText = this.getAttribute('data-token').toLowerCase();
                            const tokenIndex = this.getAttribute('data-token-index');
                            
                            // Check if ctrl/cmd key is pressed for multi-select
                            const isMultiSelectMode = event.ctrlKey || event.metaKey;
                            
                            // If multi-select mode is not active and no shift key, clear previous selections
                            if (!isMultiSelectMode && !event.shiftKey) {
                                // Clear all selections if not in multi-select mode
                                window.selectedTokens = [];
                                document.querySelectorAll('.token-item').forEach(el => {
                                    el.style.backgroundColor = '#f0f8ff';
                                    el.removeAttribute('data-selected');
                                });
                            }
                            
                            // Check if this token is already selected (for toggle)
                            const alreadySelected = this.hasAttribute('data-selected');
                            
                            if (alreadySelected) {
                                // If already selected, toggle off in multi-select mode
                                if (isMultiSelectMode) {
                                    this.style.backgroundColor = '#f0f8ff';
                                    this.removeAttribute('data-selected');
                                    
                                    // Remove alignment indicator if present
                                    const alignmentBadge = this.querySelector('.alignment-indicator');
                                    if (alignmentBadge) {
                                        this.removeChild(alignmentBadge);
                                    }
                                    
                                    // Remove from selectedTokens array
                                    const index = window.selectedTokens.findIndex(t => 
                                        t.text === tokenText && t.index === tokenIndex);
                                    if (index !== -1) {
                                        window.selectedTokens.splice(index, 1);
                                    }
                                } else {
                                    // In single select mode, just reselect this token
                                    this.style.backgroundColor = '#b3d9ff';
                                    this.setAttribute('data-selected', 'true');
                                    window.selectedTokens = [{
                                        text: tokenText,
                                        index: tokenIndex
                                    }];
                                }
                            } else {
                                // If shift key is pressed, select range
                                if (event.shiftKey && window.selectedTokens.length > 0) {
                                    // Get all token items
                                    const allTokens = Array.from(document.querySelectorAll('.token-item'));
                                    const currentIndex = allTokens.indexOf(this);
                                    
                                    // Find the last selected token's index
                                    const lastSelectedElement = document.querySelector('.token-item[data-selected="true"]');
                                    const lastSelectedIndex = lastSelectedElement ? allTokens.indexOf(lastSelectedElement) : -1;
                                    
                                    if (lastSelectedIndex !== -1) {
                                        // Determine the range
                                        const startIdx = Math.min(currentIndex, lastSelectedIndex);
                                        const endIdx = Math.max(currentIndex, lastSelectedIndex);
                                        
                                        // Select all tokens in the range
                                        for (let i = startIdx; i <= endIdx; i++) {
                                            const token = allTokens[i];
                                            token.style.backgroundColor = '#b3d9ff';
                                            token.setAttribute('data-selected', 'true');
                                            
                                            // Add alignment indicator if not already present
                                            if (!token.querySelector('.alignment-indicator')) {
                                                const badge = document.createElement('span');
                                                badge.className = 'alignment-indicator';
                                                badge.style.position = 'absolute';
                                                badge.style.top = '0';
                                                badge.style.right = '0';
                                                badge.style.backgroundColor = '#198754';
                                                badge.style.color = 'white';
                                                badge.style.borderRadius = '50%';
                                                badge.style.width = '16px';
                                                badge.style.height = '16px';
                                                badge.style.fontSize = '10px';
                                                badge.style.display = 'flex';
                                                badge.style.justifyContent = 'center';
                                                badge.style.alignItems = 'center';
                                                badge.innerHTML = '<i class="fas fa-link" style="font-size: 8px;"></i>';
                                                badge.title = "This token will be aligned";
                                                token.style.position = 'relative';
                                                token.appendChild(badge);
                                            }
                                            
                                            const tText = token.getAttribute('data-token').toLowerCase();
                                            const tIndex = token.getAttribute('data-token-index');
                                            
                                            // Add to selectedTokens if not already there
                                            if (!window.selectedTokens.some(t => t.text === tText && t.index === tIndex)) {
                                                window.selectedTokens.push({
                                                    text: tText,
                                                    index: tIndex
                                                });
                                            }
                                        }
                                    }
                                } else {
                                    // Normal selection of a single token
                                    this.style.backgroundColor = '#b3d9ff';
                                    this.setAttribute('data-selected', 'true');
                                    
                                    // Add alignment indicator if not already present
                                    if (!this.querySelector('.alignment-indicator')) {
                                        const badge = document.createElement('span');
                                        badge.className = 'alignment-indicator';
                                        badge.style.position = 'absolute';
                                        badge.style.top = '0';
                                        badge.style.right = '0';
                                        badge.style.backgroundColor = '#198754';
                                        badge.style.color = 'white';
                                        badge.style.borderRadius = '50%';
                                        badge.style.width = '16px';
                                        badge.style.height = '16px';
                                        badge.style.fontSize = '10px';
                                        badge.style.display = 'flex';
                                        badge.style.justifyContent = 'center';
                                        badge.style.alignItems = 'center';
                                        badge.innerHTML = '<i class="fas fa-link" style="font-size: 8px;"></i>';
                                        badge.title = "This token will be aligned";
                                        this.style.position = 'relative';
                                        this.appendChild(badge);
                                    }
                                    
                                    // Add to selectedTokens array
                                    window.selectedTokens.push({
                                        text: tokenText,
                                        index: tokenIndex
                                    });
                                }
                            }
                            
                            // Sort selected tokens based on their position in the sentence
                            window.selectedTokens.sort((a, b) => parseInt(a.index) - parseInt(b.index));
                            
                            // Log selections
                            console.log('Selected tokens:', window.selectedTokens);
                            
                            // Show multi-selection instructions if multiple tokens selected
                            const multiSelectInstructions = document.getElementById('multi-select-instructions');
                            if (window.selectedTokens.length > 1) {
                                if (!multiSelectInstructions) {
                                    const instructionsDiv = document.createElement('div');
                                    instructionsDiv.id = 'multi-select-instructions';
                                    instructionsDiv.className = 'alert alert-info mt-2';
                                    instructionsDiv.innerHTML = `
                                        <p class="mb-1"><strong>${window.selectedTokens.length} tokens selected</strong></p>
                                        <p class="mb-0">These tokens will be joined with hyphens: <strong>${window.selectedTokens.map(t => t.text).join('-')}</strong></p>
                                    `;
                                    document.getElementById('tokens-container').appendChild(instructionsDiv);
                                } else {
                                    multiSelectInstructions.innerHTML = `
                                        <p class="mb-1"><strong>${window.selectedTokens.length} tokens selected</strong></p>
                                        <p class="mb-0">These tokens will be joined with hyphens: <strong>${window.selectedTokens.map(t => t.text).join('-')}</strong></p>
                                    `;
                                }
                            } else if (multiSelectInstructions) {
                                multiSelectInstructions.remove();
                            }
                            
                            // Show and populate frame lookup container if only one token is selected
                            const frameLookupContainer = document.getElementById('frame-lookup-container');
                            if (frameLookupContainer) {
                                if (window.selectedTokens.length === 1) {
                                    // For single token, show frame lookup
                                    document.getElementById('selected-token-text').textContent = tokenText;
                                    lemmatizeAndLookupFrames(tokenText);
                                    frameLookupContainer.style.display = 'block';
                                } else if (window.selectedTokens.length > 1) {
                                    // For multiple tokens, hide frame lookup
                                    frameLookupContainer.style.display = 'none';
                                } else {
                                    // No tokens selected
                                    frameLookupContainer.style.display = 'none';
                                }
                            }
                        });
                    });
                    
                    // Add lemmatization and frame lookup functions
                    async function lemmatizeAndLookupFrames(tokenText) {
                        try {
                            // Show loading indicator in the frame lookup container
                            document.getElementById('lemma-value').textContent = 'Loading...';
                            document.getElementById('frames-list').innerHTML = '<div class="text-muted">Loading frames...</div>';
                            
                            let lemma = tokenText;
                            
                            try {
                                // Try to use the server-side lemmatization - ensure relative URL is used
                                // For Flask Blueprints, we need to use the full path - this matches the route in main
                                const lemmaUrl = new URL('/lemmatize', window.location.origin);
                                lemmaUrl.searchParams.append('word', tokenText);
                                console.log('Fetching lemma from:', lemmaUrl.toString());
                                
                                const lemmaResponse = await fetch(lemmaUrl);
                                console.log('Lemmatization response status:', lemmaResponse.status);
                                
                                // If we get a non-OK response, log the error message
                                if (!lemmaResponse.ok) {
                                    const errorText = await lemmaResponse.text();
                                    console.error(`Lemmatization error (${lemmaResponse.status}):`, errorText);
                                    throw new Error(`Server returned ${lemmaResponse.status}: ${errorText}`);
                                }
                                
                                const lemmaData = await lemmaResponse.json();
                                console.log('Lemma data received:', lemmaData);
                                
                                if (lemmaData.success && lemmaData.lemma) {
                                    lemma = lemmaData.lemma;
                                    console.log(`Server lemmatized "${tokenText}" to "${lemma}"`);
                                }
                            } catch (error) {
                                console.warn('Server-side lemmatization failed, falling back to client-side:', error);
                            }
                            
                            // If server-side lemmatization failed, fall back to client-side
                            if (lemma === tokenText) {
                                lemma = getLemma(tokenText);
                            }
                            
                            // Display the lemma
                            document.getElementById('lemma-value').textContent = lemma || tokenText;
                            
                            // Look up frames using the lemma
                            await lookupFrames(lemma || tokenText, tokenText);
                        } catch (error) {
                            console.error('Error in lemmatization or frame lookup:', error);
                            document.getElementById('lemma-value').textContent = tokenText;
                            document.getElementById('frames-list').innerHTML = '<div class="text-danger">Error looking up frames.</div>';
                            
                            // Set up "Use token as is" button
                            setupUseAsIsButton(tokenText);
                        }
                    }
                    
                    // Function to look up frames for a lemma
                    async function lookupFrames(lemma, originalToken) {
                        try {
                            let frames = [];
                            
                            try {
                                // Try to get frames from the server - ensure relative URL is used
                                // For Flask Blueprints, we need to use the full path - this matches the route in main
                                const framesUrl = new URL('/get_frames', window.location.origin);
                                framesUrl.searchParams.append('word', lemma);
                                
                                // Add project ID parameter to use the correct language frames
                                // First try to get project ID from URL parameters
                                let projectId = null;
                                const urlParams = new URLSearchParams(window.location.search);
                                
                                // Extract from state if available
                                if (window.state && window.state.projectId) {
                                    projectId = window.state.projectId;
                                }
                                
                                // If state doesn't have it, check for project_id global variable
                                if (!projectId && typeof project_id !== 'undefined') {
                                    projectId = project_id;
                                }
                                
                                // If still not found, try to extract from path
                                if (!projectId) {
                                    // Try to find project ID in path
                                    const pathMatch = window.location.pathname.match(/\/project\/(\d+)/);
                                    if (pathMatch) {
                                        projectId = pathMatch[1];
                                    }
                                }
                                
                                if (projectId) {
                                    framesUrl.searchParams.append('project_id', projectId);
                                    console.log('Adding project ID to frames request:', projectId);
                                }
                                
                                console.log('Fetching frames from:', framesUrl.toString());
                                
                                const framesResponse = await fetch(framesUrl);
                                console.log('Frame lookup response status:', framesResponse.status);
                                
                                // If we get a non-OK response, log the error message
                                if (!framesResponse.ok) {
                                    const errorText = await framesResponse.text();
                                    console.error(`Error response (${framesResponse.status}):`, errorText);
                                    throw new Error(`Server returned ${framesResponse.status}: ${errorText}`);
                                }
                                
                                const framesData = await framesResponse.json();
                                console.log('Frames data received:', framesData);
                                
                                if (framesData.frames && Array.isArray(framesData.frames)) {
                                    frames = framesData.frames;
                                    console.log(`Found ${frames.length} frames for "${lemma}":`, frames);
                                }
                            } catch (error) {
                                console.warn('Server-side frame lookup failed:', error);
                            }
                            
                            // Populate frames list
                            const framesList = document.getElementById('frames-list');
                            framesList.innerHTML = ''; // Clear existing content
                            
                            if (frames.length > 0) {
                                // Create a grid for the frames
                                const framesGrid = document.createElement('div');
                                framesGrid.style.display = 'grid';
                                framesGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(180px, 1fr))';
                                framesGrid.style.gap = '8px';
                                
                                // Add frames to the grid
                                frames.forEach(frame => {
                                    const frameButton = document.createElement('button');
                                    frameButton.className = 'btn btn-outline-primary btn-sm';
                                    frameButton.style.textAlign = 'left';
                                    frameButton.style.whiteSpace = 'nowrap';
                                    frameButton.style.overflow = 'hidden';
                                    frameButton.style.textOverflow = 'ellipsis';
                                    frameButton.style.marginBottom = '5px';
                                    frameButton.textContent = frame;
                                    frameButton.setAttribute('data-frame', frame);
                                    frameButton.title = `Click to select ${frame}`; // Better tooltip
                                    
                                    frameButton.addEventListener('click', function() {
                                        // Remove active class from all frame buttons
                                        document.querySelectorAll('#frames-list button').forEach(btn => {
                                            btn.classList.remove('active');
                                        });
                                        
                                        // Add active class to clicked button
                                        this.classList.add('active');
                                        
                                        // Set concept value without showing the custom concept container
                                        window.selectedFrameConcept = this.getAttribute('data-frame');
                                        console.log('Selected frame concept:', window.selectedFrameConcept);
                                        
                                        // Show a confirmation message
                                        const confirmMessage = document.createElement('div');
                                        confirmMessage.className = 'alert alert-success mt-3';
                                        confirmMessage.style.fontSize = '0.9rem';
                                        confirmMessage.innerHTML = `
                                            <strong>Selected frame:</strong> ${frame}
                                            <p class="mb-0 mt-1">Click "Create Node" to use this frame.</p>
                                        `;
                                        
                                        // Find or create the frame confirmation container
                                        let confirmContainer = document.getElementById('frame-selection-confirm');
                                        if (!confirmContainer) {
                                            confirmContainer = document.createElement('div');
                                            confirmContainer.id = 'frame-selection-confirm';
                                            document.getElementById('frames-container').appendChild(confirmContainer);
                                        }
                                        
                                        // Update the confirmation message
                                        confirmContainer.innerHTML = '';
                                        confirmContainer.appendChild(confirmMessage);
                                    });
                                    
                                    framesGrid.appendChild(frameButton);
                                });
                                
                                // Add a helpful message
                                const helpMessage = document.createElement('div');
                                helpMessage.className = 'text-muted mt-3';
                                helpMessage.style.fontSize = '0.9rem';
                                helpMessage.innerHTML = `
                                    <p>Found ${frames.length} frame(s) for "${lemma}". Click a frame to select it.</p>
                                `;
                                framesGrid.appendChild(helpMessage);
                                
                                framesList.appendChild(framesGrid);
                            } else {
                                // No frames found, display a message
                                framesList.innerHTML = `
                                    <div class="alert alert-info">
                                        <p>No frames found for "${lemma}".</p>
                                        <p class="mb-0">You can use the token as is or enter a custom concept.</p>
                                    </div>
                                `;
                            }
                            
                            // Set up "Use token as is" button
                            setupUseAsIsButton(originalToken);
                            
                        } catch (error) {
                            console.error('Error looking up frames:', error);
                            document.getElementById('frames-list').innerHTML = `
                                <div class="alert alert-warning">
                                    <p>Error looking up frames.</p>
                                    <p class="mb-0">The server endpoint may not be set up. You can use the token as is.</p>
                                </div>
                            `;
                            
                            // Set up "Use token as is" button
                            setupUseAsIsButton(originalToken);
                        }
                    }
                    
                    // Function to set up the "Use token as is" button
                    function setupUseAsIsButton(tokenText) {
                        const useAsIsButton = document.getElementById('use-token-as-is');
                        
                        // Remove any existing event listeners (to avoid duplicates)
                        const newUseAsIsButton = useAsIsButton.cloneNode(true);
                        useAsIsButton.parentNode.replaceChild(newUseAsIsButton, useAsIsButton);
                        
                        // Add the event listener to the new button
                        newUseAsIsButton.addEventListener('click', function() {
                            // Remove active class from all frame buttons
                            document.querySelectorAll('#frames-list button').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            
                            // Store the original token as the selected concept
                            window.selectedFrameConcept = tokenText;
                            console.log('Using token as is:', window.selectedFrameConcept);
                        });
                    }
                    
                    // Helper function for lemmatization
                    function getLemma(word) {
                        try {
                            // Try using the lemmatizer library if available
                            if (typeof Lemmatizer !== 'undefined' && typeof _ !== 'undefined') {
                                try {
                                    const lemmatizer = new Lemmatizer();
                                    const lemmas = lemmatizer.lemmas(word);
                                    if (lemmas && lemmas.length > 0) {
                                        console.log(`Lemmatized "${word}" to "${lemmas[0][0]}" using JavaScript lemmatizer`);
                                        return lemmas[0][0]; // Return the first lemma
                                    }
                                } catch (lemmaError) {
                                    console.warn('JavaScript lemmatizer error:', lemmaError);
                                    // Continue to fallback rules
                                }
                            } else {
                                console.warn('Lemmatizer library or Underscore.js not available, using fallback rules');
                            }
                            
                            // Fallback to simple rules for English
                            let lemma = word;
                            if (word.endsWith('ing')) {
                                lemma = word.slice(0, -3);
                                if (lemma.length < 2) lemma = word; // Avoid too short lemmas
                            } else if (word.endsWith('ed') && word.length > 3) {
                                lemma = word.slice(0, -2);
                                if (lemma.length < 2) lemma = word; // Avoid too short lemmas
                            } else if (word.endsWith('s') && !word.endsWith('ss') && word.length > 2) {
                                lemma = word.slice(0, -1);
                            } else if (word.endsWith('es') && word.length > 3) {
                                lemma = word.slice(0, -2);
                            }
                            
                            if (lemma !== word) {
                                console.log(`Applied fallback rules to get lemma "${lemma}" from "${word}"`);
                            } else {
                                console.log(`No matching lemmatization rule for "${word}", using as is`);
                            }
                            
                            return lemma;
                            
                        } catch (error) {
                            console.error('Critical error during lemmatization:', error);
                            return word; // Return original word on critical error
                        }
                    }
                    
                    // Set up auto-generate variable button
                    document.getElementById('generate-variable-btn').addEventListener('click', function() {
                        let concept = '';
                        const conceptType = conceptTypeSelect.value;
                        
                        if (conceptType === 'token') {
                            const selectedToken = document.querySelector('.token-item[style*="background-color: rgb(179, 217, 255)"]');
                            if (selectedToken) {
                                concept = selectedToken.getAttribute('data-token').toLowerCase();
                            }
                        } else if (conceptType === 'discourse') {
                            concept = document.getElementById('discourse-concept').value;
                        } else if (conceptType === 'abstract') {
                            concept = document.getElementById('abstract-concept').value;
                        } else if (conceptType === 'ne') {
                            concept = document.getElementById('ne-type').value;
                        } else if (conceptType === 'non-event') {
                            concept = document.getElementById('non-event-roleset').value;
                        } else if (conceptType === 'custom') {
                            concept = document.getElementById('custom-concept').value;
                        }
                        
                        if (concept) {
                            document.getElementById('variable-input').value = generateVariable(concept);
                        } else {
                            alert('Please select or enter a concept first');
                        }
                    });
                    
                    // Set up form submission
                    document.getElementById('add-top-form').addEventListener('submit', function(e) {
                        e.preventDefault();
                        
                        // Get the selected/entered concept
                        let concept = '';
                        let tokenIndices = [];
                        const conceptType = conceptTypeSelect.value;
                        
                        if (!conceptType) {
                            alert('Please select a concept type');
                            return;
                        }
                        
                        if (conceptType === 'token') {
                            // Check if any tokens are selected
                            if (window.selectedTokens.length === 0) {
                                alert('Please select at least one token');
                                return;
                            }
                            
                            if (window.selectedTokens.length === 1) {
                                // Single token selection
                                // Use the selectedFrameConcept if available
                                if (window.selectedFrameConcept) {
                                    concept = window.selectedFrameConcept;
                                    console.log(`Using selected frame/lemma as concept: "${concept}"`);
                                } else {
                                    // Otherwise use the token text
                                    concept = window.selectedTokens[0].text;
                                    console.log(`No frame selected, using token text: "${concept}"`);
                                }
                                tokenIndices = [window.selectedTokens[0].index];
                                console.log(`Adding alignment for token: ${window.selectedTokens[0].text} (index: ${window.selectedTokens[0].index})`);
                            } else {
                                // Multiple tokens selected - join with hyphens
                                concept = window.selectedTokens.map(token => token.text).join('-');
                                tokenIndices = window.selectedTokens.map(token => token.index);
                                console.log(`Using multi-token concept: "${concept}" with indices: [${tokenIndices.join(', ')}]`);
                                console.log(`Alignment will be created for all selected tokens: ${window.selectedTokens.map(t => t.text).join(', ')}`);
                            }
                        } else if (conceptType === 'discourse') {
                            concept = document.getElementById('discourse-concept').value;
                            if (!concept) {
                                alert('Please select a discourse concept');
                                return;
                            }
                        } else if (conceptType === 'abstract') {
                            concept = document.getElementById('abstract-concept').value;
                            if (!concept) {
                                alert('Please select an abstract concept');
                                return;
                            }
                        } else if (conceptType === 'ne') {
                            concept = document.getElementById('ne-type').value;
                            if (!concept) {
                                alert('Please select a named entity type');
                                return;
                            }
                            
                            // For named entities, use the selected name tokens for alignment
                            if (window.selectedNameTokens.length > 0) {
                                tokenIndices = window.selectedNameTokens.map(token => token.index);
                                console.log(`Named entity "${concept}" with name tokens: [${window.selectedNameTokens.map(t => t.text).join(', ')}]`);
                                console.log(`Using name token indices for alignment: [${tokenIndices.join(', ')}]`);
                            } else {
                                console.log(`Named entity "${concept}" without name tokens`);
                            }
                        } else if (conceptType === 'non-event') {
                            concept = document.getElementById('non-event-roleset').value;
                            if (!concept) {
                                alert('Please select a reification roleset');
                                return;
                            }
                        } else if (conceptType === 'custom') {
                            concept = document.getElementById('custom-concept').value;
                            if (!concept) {
                                alert('Please enter a custom concept');
                                return;
                            }
                        }
                        
                        // Get variable (or generate one if empty)
                        let variable = document.getElementById('variable-input').value.trim();
                        if (!variable) {
                            variable = generateVariable(concept);
                        }
                        
                        // Reset the global variables
                        window.selectedFrameConcept = null;
                        window.selectedTokens = [];
                        window.selectedNameTokens = [];
                        
                        // Create top node with alignment if applicable
                        const submitButton = document.getElementById('confirm-add-top');
                        const originalButtonText = submitButton.innerHTML;
                        
                        // Show processing state
                        submitButton.disabled = true;
                        submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
                        
                        // Add a status message if we're creating alignments
                        if (tokenIndices && tokenIndices.length > 0) {
                            const statusMsg = document.createElement('div');
                            statusMsg.className = 'alert alert-info mt-2';
                            statusMsg.innerHTML = `Processing alignment for "${concept}" with ${tokenIndices.length} token(s)...`;
                            document.getElementById('add-top-form').appendChild(statusMsg);
                        }
                        
                        createTopNode(variable, concept, tokenIndices);
                    });
                    
                    // Set up cancel button
                    document.getElementById('cancel-add-top').addEventListener('click', function() {
                        // Reset selections before closing
                        window.selectedFrameConcept = null;
                        window.selectedTokens = [];
                        resetNameTokens();
                        
                        document.body.removeChild(dialogContainer);
                    });
                    
                } catch (error) {
                    console.error('Error setting up Add Top dialog:', error);
                    alert('Error setting up dialog: ' + error.message);
                    document.body.removeChild(dialogContainer);
                }
                
                // Helper function to populate dropdown with options
                function populateDropdown(selectId, options) {
                    const select = document.getElementById(selectId);
                    options.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option;
                        optionElement.textContent = option;
                        select.appendChild(optionElement);
                    });
                }
                
                // Helper function to setup filtering for dropdowns
                function setupFiltering(searchId, selectId, options) {
                    const searchInput = document.getElementById(searchId);
                    const select = document.getElementById(selectId);
                    
                    searchInput.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const filteredOptions = options.filter(option => 
                            option.toLowerCase().includes(searchTerm)
                        );
                        
                        // Clear existing options
                        while (select.options.length > 1) {
                            select.remove(1);
                        }
                        
                        // Add filtered options
                        filteredOptions.forEach(option => {
                            const optionElement = document.createElement('option');
                            optionElement.value = option;
                            optionElement.textContent = option;
                            select.appendChild(optionElement);
                        });
                    });
                }
                
                // Helper function to setup filtering for tokens
                function setupTokensFiltering(searchId, gridId) {
                    const searchInput = document.getElementById(searchId);
                    const grid = document.getElementById(gridId);
                    const tokenItems = grid.querySelectorAll('.token-item');
                    
                    searchInput.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        
                        tokenItems.forEach(item => {
                            const tokenText = item.getAttribute('data-token').toLowerCase();
                            // Also search in the full original text for more flexibility
                            const fullText = item.getAttribute('data-full-text')?.toLowerCase() || '';
                            
                            if (tokenText.includes(searchTerm) || fullText.includes(searchTerm)) {
                                item.style.display = 'block';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                }
                
                // Helper function to close the dialog
                function closeDialog() {
                    document.body.removeChild(dialogContainer);
                }
                
                // Helper function to extract tokens from the current sentence
                function extractSentenceTokens() {
                    try {
                        const currentSentenceElement = document.querySelector('.current-sentence');
                        if (!currentSentenceElement) return [];
                        
                        // Try to find word elements
                        const wordElements = currentSentenceElement.querySelectorAll('.word');
                        if (wordElements && wordElements.length > 0) {
                            // Return array of objects with token text and index
                            return Array.from(wordElements).map((el, i) => {
                                const fullText = el.textContent.trim();
                                
                                // Extract index from the element's data attribute if available
                                let index = el.getAttribute('data-index') || (i + 1);
                                
                                // If the text starts with a number followed by non-numeric content,
                                // assume the number is the index and extract the actual token text
                                const match = fullText.match(/^(\d+)(.+)$/);
                                let text = fullText;
                                
                                if (match) {
                                    // Use the number as the index and the rest as the text
                                    index = match[1];
                                    text = match[2];
                                }
                                
                                return {
                                    text: text,
                                    fullText: fullText, // Keep the original text for reference
                                    index: index
                                };
                            });
                        }
                        
                        // Fallback: just split the text by spaces (without indices)
                        const sentenceText = currentSentenceElement.textContent.trim();
                        return sentenceText.split(/\s+/).map((text, index) => {
                            // Check if text starts with a number
                            const match = text.match(/^(\d+)(.+)$/);
                            if (match) {
                                return {
                                    text: match[2],
                                    fullText: text,
                                    index: match[1]
                                };
                            }
                            
                            return {
                                text: text,
                                fullText: text,
                                index: index + 1
                            };
                        });
                    } catch (error) {
                        console.error('Error extracting sentence tokens:', error);
                        return [];
                    }
                }
                
                // Helper function to generate a variable from a concept
                function generateVariable(concept) {
                    if (!concept) return 's' + window.state.currentId + 'x1';
                    
                    // Remove numbers and special characters to get the concept's initial letter
                    const cleanConcept = concept.replace(/[^a-zA-Z\-]/g, '');
                    
                    // Take the first character, or 'x' if empty
                    let firstChar = cleanConcept.charAt(0).toLowerCase();
                    if (!firstChar) firstChar = 'x';
                    
                    // Initialize the concept counters if they don't exist
                    if (!window.conceptCounters) {
                        window.conceptCounters = {};
                    }
                    
                    // Get the sentence ID from the window state
                    const sentenceId = window.state.currentId;
                    
                    // Create a key for tracking this letter in this sentence
                    const counterKey = `s${sentenceId}${firstChar}`;
                    
                    // Increment or initialize the counter for this letter
                    if (!window.conceptCounters[counterKey]) {
                        window.conceptCounters[counterKey] = 1;
                    } else {
                        window.conceptCounters[counterKey]++;
                    }
                    
                    // Format: s[sentence_number][initial_letter][counter]
                    return `s${sentenceId}${firstChar}${window.conceptCounters[counterKey]}`;
                }
                
                // Function to create the top node
                function createTopNode(variable, concept, tokenIndices) {
                    // Create UMR string for top node
                    const umrString = `(${variable} / ${concept})`;
                    
                    // Update the annotation
                    const docVersionId = document.getElementById('doc_version_id').value;
                    const sentId = document.getElementById('snt_id').value;
                    
                    // Create request data with alignment if token indices exist
                    const requestData = {
                        annotation: umrString,
                        operation: 'add_top'
                    };
                    
                    // Add alignment information if token indices exist
                    if (tokenIndices && tokenIndices.length > 0) {
                        // Format token indices as ranges (e.g. "5-5" for single token or "5-6-7" for multiple tokens)
                        const formattedIndices = tokenIndices.map(index => `${index}-${index}`);
                        
                        requestData.alignment = {
                            [variable]: formattedIndices
                        };
                        console.log(`Adding alignment for ${variable} with formatted ranges: ${formattedIndices.join(', ')}`);
                    } else {
                        console.log(`No alignment information for ${variable}`);
                    }
                    
                    console.log('Request data for creating top node:', requestData);
                    
                    fetch(`/update_annotation/${docVersionId}/${sentId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            const hasAlignment = tokenIndices && tokenIndices.length > 0;
                            const successMessage = hasAlignment 
                                ? `Top node created successfully with alignment: ${variable}:[${tokenIndices.join('-')}]` 
                                : 'Top node created successfully';
                            
                            console.log(successMessage);
                            
                            // Create and show a temporary success notification
                            const notification = document.createElement('div');
                            notification.className = 'alert alert-success';
                            notification.style.position = 'fixed';
                            notification.style.top = '20px';
                            notification.style.left = '50%';
                            notification.style.transform = 'translateX(-50%)';
                            notification.style.padding = '10px 20px';
                            notification.style.borderRadius = '5px';
                            notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                            notification.style.zIndex = '9999';
                            notification.style.maxWidth = '80%';
                            notification.innerHTML = `
                                <strong>Success!</strong> ${successMessage}
                                ${hasAlignment ? `<div><small>Alignment "${variable}:[${tokenIndices.map(idx => idx+'-'+idx).join(', ')}]" has been added to the database.</small></div>` : ''}
                                ${hasAlignment ? '<div><small>Alignment information will be displayed in the right panel after reload.</small></div>' : ''}
                            `;
                            
                            document.body.appendChild(notification);
                            
                            // Remove the notification after a delay
                            setTimeout(() => {
                                document.body.removeChild(notification);
                                
                                // Close the dialog
                                closeDialog();
                                
                                // Reload the page to reflect the changes
                                window.location.reload();
                            }, 2000);
                        } else {
                            alert('Failed to create top node: ' + data.message);
                        }
                    })
                    .catch(err => {
                        console.error('Failed to create top node:', err);
                        alert('Failed to create top node: ' + err.message);
                    });
                }
            }
        });
    </script>
    
    <style>
        /* Custom styles for relation editing */
        .relation-span {
            position: relative;
            cursor: pointer;
            color: #0066cc;
            transition: background-color 0.2s;
        }
        
        .relation-span:hover {
            background-color: #e6f7ff;
        }
        
        #amr pre {
            white-space: pre-wrap;
        }
    </style>
{% endblock head %}

{% block content %}
<div class="container-fluid">
    <!-- Hidden fields for JavaScript -->
    <input type="hidden" id="doc_id" value="{{ doc_id }}">
    <input type="hidden" id="doc_version_id" value="{{ doc_version_id }}">
    <input type="hidden" id="user_id" value="{{ owner.id }}">
    <input type="hidden" id="snt_id" value="{{ snt_id }}">
    <input type="hidden" id="maxSentId" value="{{ info2display.sents|length }}">
    
    <div class="split-container">
        <!-- Left Panel -->
        <div class="split left-panel">
            <!-- Document Navigation -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">Navigation</h5>
                    <div class="navigation-controls">
                        <button class="btn btn-sm btn-outline-primary" onclick="prevSentence()">←</button>
                        <span class="mx-2">{{ snt_id }} / {{ info2display.sents|length }}</span>
                        <button class="btn btn-sm btn-outline-primary" onclick="nextSentence()">→</button>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="list-group list-group-flush sentences-container" id="sentence-container">
                        {% for sent in info2display.sents %}
                        <a href="{{ url_for('main.sentlevel', doc_version_id=doc_version_id, sent_id=loop.index) }}" 
                           class="list-group-item list-group-item-action {% if loop.index == snt_id %}active{% endif %}">
                            <small class="text-muted">#{{ loop.index }}</small>
                            <span class="sentence-text">{{ sent }}</span>
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>

            <!-- Current Sentence Details -->
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0" id="editable-sentence" docId="{{ doc_id }}" sntId="{{ snt_id }}">Current Sentence</h5>
                        <button id="edit-sentence-btn" class="btn btn-sm btn-outline-primary" title="Edit word segmentation">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                    </div>
                </div>
                <div class="card-body" >
                    <div class="current-sentence" id="sentence-display">
                        {% if info2display.sent_htmls and snt_id > 0 and snt_id <= info2display.sent_htmls|length %}
                            {{ info2display.sent_htmls[snt_id-1]|safe }}
                        {% else %}
                            <div class="alert alert-warning">No sentence content available.</div>
                        {% endif %}
                    </div>
                    <textarea id="sentence-editor" class="form-control" style="display:none; font-size: 1.1rem; line-height: 2.5; min-height: 80px;"></textarea>
                    <div class="sentence-details">
                        <div class="translation-box">
                            {% if info2display.gls and snt_id > 0 and snt_id <= info2display.gls|length %}
                                <div class="translation-item">
                                    <span class="badge bg-secondary">EN</span>
                                    {{ info2display.gls[snt_id-1][0] }}
                                </div>
                                <div class="translation-item">
                                    <span class="badge bg-secondary">ES</span>
                                    {{ info2display.gls[snt_id-1][1] }}
                                </div>
                            {% endif %}
                        </div>
                        {% if info2display.notes and snt_id > 0 and snt_id <= info2display.notes|length and info2display.notes[snt_id-1] %}
                        <div class="notes-box mt-2">
                            <span class="badge bg-info">Notes</span>
                            {{ info2display.notes[snt_id-1] }}
                        </div>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Annotation Preview -->
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Sentence-Level UMR Annotation Preview</h5>
                        <div class="d-flex align-items-center">
                            <div id="edit-mode-toggle-placeholder" class="me-3"></div>
                            <div class="btn-group">
                            {% if curr_annotation_string %}
                            <button id="save-annotation-btn" class="btn btn-sm btn-outline-primary me-2" title="Save annotation and alignments">
                                <i class="fas fa-save"></i> Save
                            </button>
                            <button id="validate-annotation-btn" class="btn btn-sm btn-outline-warning me-2" title="Validate graph structure">
                                <i class="fas fa-check-circle"></i> Validate
                            </button>
                            <button id="delete-annotation-btn" class="btn btn-sm btn-outline-danger me-2" title="Delete entire annotation">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                            <button id="copy-annotation-btn" class="btn btn-sm btn-outline-secondary me-2" title="Copy to clipboard">
                                <i class="fas fa-copy"></i> Copy
                            </button>
                            <button id="paren-check-btn" class="btn btn-sm btn-outline-info me-2" title="Check parenthesis matching" onclick="toggleParenChecker()">
                                <i class="fas fa-check-circle"></i> Parens
                            </button>
                            <button id="diff-view-btn" class="btn btn-sm btn-outline-success" title="Show changes" onclick="toggleDiffView()">
                                <i class="fas fa-exchange-alt"></i> Diff
                            </button>
                            {% else %}
                            <button id="add-top-btn" class="btn btn-sm btn-primary" title="Create the first node">
                                <i class="fas fa-plus"></i> Add Top
                            </button>
                            {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="amr-wrapper">
                        <div class="amr-table">
                            <div class="amr-line-numbers" id="line-numbers"></div>
                            <div class="amr-content-cell">
                                <div id="amr" class="annotation-preview">
                                    {% if curr_annotation_string %}
                                        <pre class="mb-0">{{ curr_annotation_string }}</pre>
                                    {% else %}
                                        <div class="alert alert-info mb-0 text-center">
                                            {% if not curr_sent_umr %}
                                                <p class="mb-0">No annotation has been created for this sentence yet.</p>
                                                <p class="mb-0">Click the "Add Top" button to create your first node.</p>
                                            {% else %}
                                                <p class="mb-0">The annotation exists but is empty.</p>
                                                <p class="mb-0">Click the "Add Top" button to create your first node.</p>
                                            {% endif %}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Validation Results Area -->
                    <div id="validation-results" class="mt-3" style="display: none;">
                        <div class="card border-0">
                            <div class="card-header bg-light">
                                <h6 class="mb-0">
                                    <i class="fas fa-check-circle"></i> Validation Results
                                    <button type="button" class="btn-close btn-sm float-end" onclick="document.getElementById('validation-results').style.display='none'"></button>
                                </h6>
                            </div>
                            <div class="card-body p-2">
                                <div id="validation-errors" class="mb-2"></div>
                                <div id="validation-warnings"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Hidden element to store relations data for relation editor -->
                    <script type="application/json" id="umr-relations-data">
                        {{ relations_list|safe }}
                    </script>
                    
                    <!-- Hidden element to store relations with values for value editor -->
                    <script type="application/json" id="umr-relation-values-data">
                        {{ relations_data|safe }}
                    </script>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="split right-panel">
            <!-- Document Info (Moved to top of right panel) -->
            <div class="card mb-3">
                <div class="card-header" role="button" data-bs-toggle="collapse" data-bs-target="#docInfo" aria-expanded="true" aria-controls="docInfo" style="cursor: pointer;">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Document Info</h5>
                        <i class="fas fa-chevron-up collapse-icon-right"></i>
                    </div>
                </div>
                <div id="docInfo" class="collapse show">
                    <div class="card-body">
                        <table class="table table-sm mb-0">
                            <tr>
                                <th>Annotator:</th>
                                <td id="username-right">{{ owner.username }}</td>
                            </tr>
                            <tr>
                                <th>File:</th>
                                <td id="filename-right">{{ filename }}</td>
                            </tr>
                            <tr>
                                <th>Language:</th>
                                <td id="lang-right">{{ lang }}</td>
                            </tr>
                            <tr>
                                <th>Project:</th>
                                <td id="project_name-right">{{ project_name }}</td>
                            </tr>
                            <tr>
                                <th>Admin:</th>
                                <td id="project_admin-right">{{ admin.username }}</td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
            
            <!-- Quick Actions -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="mb-0">Quick Actions</h5>
                </div>
                <div class="card-body">
                    <div class="btn-group w-100">
                        <a class="btn btn-outline-secondary" href="{{ url_for('main.doclevel', doc_version_id=doc_version_id, sent_id=snt_id) }}">
                            Document-Level Annotation
                        </a>
                    </div>
                    <div class="btn-group w-100 mt-2">
                        <button id="export-annotation-btn" class="btn btn-outline-success" title="Export annotation to file">
                            <i class="fas fa-file-export"></i> Export Annotation
                        </button>
                    </div>
                    <div class="btn-group w-100 mt-2">
                        <a class="btn btn-outline-secondary" href="{{ url_for('users.project', project_id=project_id) }}">
                            Back to Project
                        </a>
                    </div>
                </div>
            </div>

                        
            <!-- Temporary Branch Storage -->
            <div class="card mb-3">
                <div class="card-header" role="button" data-bs-toggle="collapse" data-bs-target="#tempBranchStorage" aria-expanded="true" aria-controls="tempBranchStorage" style="cursor: pointer;">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Temporary Branch Storage</h5>
                        <i class="fas fa-chevron-up collapse-icon-temp"></i>
                    </div>
                </div>
                <div id="tempBranchStorage" class="collapse show">
                    <div class="card-body">
                        <div class="alert alert-info mb-3">
                            <small>Store branches temporarily while working across sentences. Content persists within the current document.</small>
                        </div>
                        <!-- Temporary branches will appear here -->
                        <div id="temp-branches-container" class="temp-branches-container">
                            <div class="empty-state text-center text-muted p-3">
                                <i class="fas fa-inbox fa-2x mb-2"></i>
                                <p>No branches stored yet</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
       
            <!-- Alignments -->
            <div class="card mb-3">
                <div class="card-header">
                    <h5 class="mb-0">Alignments</h5>
                </div>
                <div class="card-body">
                    <!-- Add new alignment -->
                    <div class="add-alignment mb-3">
                        <div class="input-group mb-2">
                            <input type="text" class="form-control" id="new-variable" placeholder="Variable">
                            <input type="text" class="form-control" id="new-alignment" placeholder="Alignment">
                            <button class="btn btn-info" onclick="addAlignment()">Add Alignment</button>
                        </div>
                    </div>
                    
                    <!-- Existing alignments -->
                    <div class="alignments-display">
                        {% if curr_alignment %}
                            {% for variable, alignments in curr_alignment.items() %}
                            <div class="alignment-item" data-variable="{{ variable }}">
                                <div class="d-flex align-items-center">
                                    <span class="variable badge bg-primary">{{ variable }}</span>
                                    <div class="alignments-list">
                                        {% for alignment in alignments %}
                                        <div class="alignment-entry d-flex align-items-center">
                                            <span class="alignment badge bg-secondary" onclick="makeEditable(this, '{{ variable }}', '{{ alignment }}')">{{ alignment }}</span>
                                            <button class="btn btn-sm btn-danger" onclick="deleteAlignmentValue('{{ variable }}', '{{ alignment }}')">×</button>
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                            {% endfor %}
                        {% else %}
                            <div class="alert alert-info mb-0">No alignments available for this sentence.</div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">
    // Sentence editing functionality
    function initializeSentenceEditor() {
        const editBtn = document.getElementById('edit-sentence-btn');
        const display = document.getElementById('sentence-display');
        const editor = document.getElementById('sentence-editor');

        if (!editBtn || !display || !editor) return;

        // Store original HTML structure for token display
        let originalHTML = display.innerHTML;

        editBtn.addEventListener('click', function() {
            if (editor.style.display === 'none') {
                // Enter edit mode
                // Extract text content from the display, preserving spaces
                const tokens = [];
                display.querySelectorAll('.token-item').forEach(item => {
                    const index = item.querySelector('.token-index')?.textContent || '';
                    const text = item.querySelector('.token-text')?.textContent || '';
                    tokens.push(text);
                });

                // If no token structure exists, get the raw text
                let textContent = tokens.length > 0 ? tokens.join(' ') :
                    {{ info2display.sents[snt_id-1]|tojson|safe }} || display.textContent.trim();

                editor.value = textContent;
                display.style.display = 'none';
                editor.style.display = 'block';
                editor.focus();

                editBtn.innerHTML = '<i class="fas fa-save"></i> Save';
                editBtn.classList.remove('btn-outline-primary');
                editBtn.classList.add('btn-success');
            } else {
                // Save and exit edit mode
                saveSegmentation();
            }
        });

        // Save on Enter key (Shift+Enter for new line)
        editor.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveSegmentation();
            }
        });

        function saveSegmentation() {
            const updatedText = editor.value.trim();

            // Send update to server
            fetch('/update_sentence', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({
                    doc_id: parseInt(document.getElementById('doc_id').value),
                    snt_id: parseInt(document.getElementById('snt_id').value),
                    new_content: updatedText
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success && data.html_content) {
                    // Update the display with new HTML
                    display.innerHTML = data.html_content;
                    originalHTML = data.html_content;

                    // Store the updated sentence for future edits
                    window.temp_sent = data.sent;

                    // Update the sentence in navigation box
                    const sentlevelUrl = "{{ url_for('main.sentlevel', doc_version_id=doc_version_id, sent_id=snt_id) }}";
                    const anchor = document.querySelector(`a[href="${sentlevelUrl}"]`);
                    if (anchor) {
                        const span = anchor.querySelector('span');
                        if (span) {
                            // Display the segmented sentence in navigation
                            span.textContent = updatedText;
                        }
                    }

                    // Show success notification
                    showNotification('Segmentation updated successfully', 'success');
                } else {
                    display.innerHTML = '<div class="alert alert-danger">' + (data.error || 'Failed to update') + '</div>';
                    showNotification('Failed to update segmentation', 'error');
                }

                // Exit edit mode
                editor.style.display = 'none';
                display.style.display = 'block';
                editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
                editBtn.classList.remove('btn-success');
                editBtn.classList.add('btn-outline-primary');
            })
            .catch(error => {
                console.error('Error updating segmentation:', error);
                showNotification('Error updating segmentation', 'error');

                // Exit edit mode even on error
                editor.style.display = 'none';
                display.style.display = 'block';
                editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
                editBtn.classList.remove('btn-success');
                editBtn.classList.add('btn-outline-primary');
            });
        }

        function showNotification(message, type) {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.segmentation-notification');
            existingNotifications.forEach(n => n.remove());

            // Create notification
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : 'success'} segmentation-notification`;
            notification.style.position = 'fixed';
            notification.style.top = '70px';
            notification.style.right = '20px';
            notification.style.zIndex = '9999';
            notification.style.minWidth = '250px';
            notification.innerHTML = `
                <i class="fas fa-${type === 'error' ? 'times' : 'check'}-circle"></i> ${message}
            `;
            document.body.appendChild(notification);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 3000);
        }

        function getCsrfToken() {
            const token = document.querySelector('[name=csrf_token]');
            if (token) return token.value;

            // Fallback: get from cookie
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'csrf_token') return value;
            }
            return '';
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize sentence editor
        initializeSentenceEditor();
        // Initialize split panels
        Split(['.left-panel', '.right-panel'], {
            sizes: [70, 30],
            minSize: [300, 200],
            gutterSize: 8,
            snapOffset: 0,
            dragInterval: 1,
            cursor: 'col-resize'
        });

        // Initialize alignments
        const currentAlignments = {{ curr_alignment|tojson|safe }};
        initializeAlignments(currentAlignments);        

        // Handle collapse icon rotation for the right panel Document Info
        const docInfoHeader = document.querySelector('[data-bs-target="#docInfo"]');
        const collapseIconRight = docInfoHeader.querySelector('.collapse-icon-right');
        
        docInfoHeader.addEventListener('click', function() {
            collapseIconRight.classList.toggle('fa-chevron-down');
            collapseIconRight.classList.toggle('fa-chevron-up');
        });

        // Initialize collapse for right panel Document Info
        const docInfo = document.getElementById('docInfo');
        docInfo.addEventListener('show.bs.collapse', function () {
            collapseIconRight.classList.remove('fa-chevron-down');
            collapseIconRight.classList.add('fa-chevron-up');
        });
        
        docInfo.addEventListener('hide.bs.collapse', function () {
            collapseIconRight.classList.remove('fa-chevron-up');
            collapseIconRight.classList.add('fa-chevron-down');
        });
                
        // Handle collapse icon rotation for Temporary Branch Storage
        const tempStorageHeader = document.querySelector('[data-bs-target="#tempBranchStorage"]');
        const collapseIconTemp = tempStorageHeader.querySelector('.collapse-icon-temp');
        
        tempStorageHeader.addEventListener('click', function() {
            collapseIconTemp.classList.toggle('fa-chevron-down');
            collapseIconTemp.classList.toggle('fa-chevron-up');
        });

        // Initialize collapse for Temporary Branch Storage
        const tempBranchStorage = document.getElementById('tempBranchStorage');
        tempBranchStorage.addEventListener('show.bs.collapse', function () {
            collapseIconTemp.classList.remove('fa-chevron-down');
            collapseIconTemp.classList.add('fa-chevron-up');
        });
        
        tempBranchStorage.addEventListener('hide.bs.collapse', function () {
            collapseIconTemp.classList.remove('fa-chevron-up');
            collapseIconTemp.classList.add('fa-chevron-down');
        });
        
        // Initialize temporary branch storage
        initTempBranchStorage();
    });


    function prevSentence() {
        const sntId = parseInt("{{ snt_id }}");
        if (sntId > 1) {
            window.location.href = "{{ url_for('main.sentlevel', doc_version_id=doc_version_id, sent_id=snt_id - 1) }}";
        }
    }

    function nextSentence() {
        const sntId = parseInt("{{ snt_id }}");
        const maxId = parseInt("{{ info2display.sents|length }}");
        if (sntId < maxId) {
            window.location.href = "{{ url_for('main.sentlevel', doc_version_id=doc_version_id, sent_id=snt_id + 1) }}";
        }
    }
    
    // Export annotation functionality
    document.addEventListener('DOMContentLoaded', function() {
        const exportButton = document.getElementById('export-annotation-btn');
        if (exportButton) {
            exportButton.addEventListener('click', function() {
                exportAnnotation();
            });
        }
    });

    document.addEventListener('DOMContentLoaded', function() {
        const sentlevelUrl = "{{ url_for('main.sentlevel', doc_version_id=doc_version_id, sent_id=snt_id) }}";
        const anchor = document.querySelector(`a[href="${sentlevelUrl}"]`);
        if (anchor) {
            const container = document.getElementById('sentence-container');
            if (container && anchor.scrollIntoView) {
                anchor.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    });
    
    function exportAnnotation() {
        console.log('Starting annotation export process');
        
        // Show a loading spinner
        const exportButton = document.getElementById('export-annotation-btn');
        const originalButtonHtml = exportButton.innerHTML;
        exportButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Exporting...';
        exportButton.disabled = true;
        
        // Get the document version ID
        const docVersionId = document.getElementById('doc_version_id').value;
        console.log(`Exporting annotations for document version ID: ${docVersionId}`);
        
        // Show status notification
        showExportNotification('Fetching annotation data...', 'info');
        
        // Fetch all the annotation data for the document
        fetch(`/export_annotation/${docVersionId}`, {
            method: 'GET',
            headers: {
                'Accept': 'text/plain, application/json'
            }
        })
        .then(response => {
            console.log('Server response status:', response.status);
            if (!response.ok) {
                // Try to parse error response as JSON
                return response.json().then(errorData => {
                    throw new Error(errorData.error || `Server error: ${response.status}`);
                });
            }
            
            // Check content type to determine if it's a file or JSON
            const contentType = response.headers.get('Content-Type');
            if (contentType && contentType.includes('application/json')) {
                // Handle JSON response (error case)
                return response.json().then(errorData => {
                    throw new Error(errorData.error || 'Failed to export annotation');
                });
            } else {
                // Handle file download
                return response.blob().then(blob => {
                    const filename = response.headers.get('Content-Disposition')?.split('filename=')[1] || 'export.umr';
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showExportNotification('Annotation exported successfully!', 'success');
                });
            }
        })
        .catch(error => {
            console.error('Error exporting annotation:', error);
            showExportNotification('Error: ' + error.message, 'error');
        })
        .finally(() => {
            // Restore button state
            console.log('Export process completed');
            exportButton.innerHTML = originalButtonHtml;
            exportButton.disabled = false;
        });
    }
    
    function formatUMRData(data) {
        let umrContent = '';
        
        console.log('Formatting UMR data:', data);
        
        if (!data.sentences || !Array.isArray(data.sentences)) {
            console.error('Invalid data format: sentences array is missing');
            return '# Error: Invalid data format received from server';
        }
        
        // Loop through each sentence in the document
        data.sentences.forEach((sentence, index) => {
            const sentId = index + 1;
            
            try {
                // Add sentence meta-info
                umrContent += `# meta-info :: sent_id = ${data.filename || 'unknown'}-s${sentId}\n`;
                
                // Add sentence identifier without the sentence text
                umrContent += `# :: snt${sentId}\n`;
                
                // Add word indices if available
                if (sentence.words && Array.isArray(sentence.words) && sentence.words.length > 0) {
                    umrContent += 'Index: ' + sentence.words.map((_, i) => i + 1).join('\t') + '\n';
                    umrContent += 'Words: ' + sentence.words.join(' ') + '\n\n';
                } else {
                    umrContent += '\n';
                }
                
                // Add sentence level annotation
                umrContent += '# sentence level graph:\n';
                if (sentence.annotation && typeof sentence.annotation === 'string' && sentence.annotation.trim()) {
                    umrContent += sentence.annotation + '\n\n\n';
                } else {
                    umrContent += '()\n\n\n';
                }
                
                // Add alignment information
                umrContent += '# alignment:\n';
                if (sentence.alignments && typeof sentence.alignments === 'object' && Object.keys(sentence.alignments).length > 0) {
                    for (const [variable, alignments] of Object.entries(sentence.alignments)) {
                        if (Array.isArray(alignments)) {
                            for (const alignment of alignments) {
                                umrContent += `${variable}: ${alignment}\n`;
                            }
                        }
                    }
                    umrContent += '\n\n';
                } else {
                    umrContent += '\n\n';
                }
                
                // Add document level annotation for this sentence
                umrContent += '# document level annotation:\n';
                if (sentence.doc_annotation && typeof sentence.doc_annotation === 'string' && sentence.doc_annotation.trim()) {
                    // Log the first few characters of the document annotation to help diagnose
                    console.log(`Document annotation for sentence ${sentId}: ${sentence.doc_annotation.substring(0, 30)}...`);
                    
                    // Add warning if the server flagged this annotation
                    if (sentence.doc_annotation_warning) {
                        umrContent += '# ' + sentence.doc_annotation_warning + '\n';
                        console.warn(`Warning for sentence ${sentId}: ${sentence.doc_annotation_warning}`);
                    }
                    
                    umrContent += sentence.doc_annotation + '\n\n\n';
                } else {
                    umrContent += '\n\n\n';
                }
                
                // Add separator between sentences
                umrContent += '################################################################################\n';
            } catch (error) {
                console.error('Error formatting UMR data:', error);
                umrContent = '# Error: Failed to format UMR data';
            }
        });
        
        return umrContent;
    }
    
    function downloadUMRFile(content, filename) {
        // Create a blob with the content
        const blob = new Blob([content], { type: 'text/plain' });
        
        // Create a download link
        const downloadLink = document.createElement('a');
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.download = filename + '.umr';
        
        // Append the link to the body
        document.body.appendChild(downloadLink);
        
        // Click the link to trigger the download
        downloadLink.click();
        
        // Clean up
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(downloadLink.href);
    }
    
    function showExportNotification(message, type) {
        // Remove any existing notifications
        const existingNotifications = document.querySelectorAll('.export-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `alert alert-${type === 'error' ? 'danger' : (type === 'info' ? 'info' : 'success')} export-notification`;
        notification.style.position = 'fixed';
        notification.style.top = '20px';
        notification.style.left = '50%';
        notification.style.transform = 'translateX(-50%)';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
        notification.style.zIndex = '9999';
        notification.innerHTML = message;
        notification.id = 'export-notification-' + Date.now();
        
        // Add notification to the document
        document.body.appendChild(notification);
        
        // For success or error messages, remove after a delay
        if (type === 'success' || type === 'error') {
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }
        // Info messages stay until the next message or success/error
    }
</script>
{% endblock content %}





